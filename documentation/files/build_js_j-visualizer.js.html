<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build/js/j-visualizer.js - j-visualizer</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="j-visualizer"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/jQuery.fn.html">jQuery.fn</a></li>
            
                <li><a href="../classes/NativeClass.Array.html">NativeClass.Array</a></li>
            
                <li><a href="../classes/NativeClass.String.html">NativeClass.String</a></li>
            
                <li><a href="../classes/Visualizer.html">Visualizer</a></li>
            
                <li><a href="../classes/Visualizer.Colorer.html">Visualizer.Colorer</a></li>
            
                <li><a href="../classes/Visualizer.Module.html">Visualizer.Module</a></li>
            
                <li><a href="../classes/Visualizer.ModuleView.html">Visualizer.ModuleView</a></li>
            
                <li><a href="../classes/Visualizer.ModuleView.ResizableMixin.html">Visualizer.ModuleView.ResizableMixin</a></li>
            
                <li><a href="../classes/Visualizer.Scene.html">Visualizer.Scene</a></li>
            
                <li><a href="../classes/Visualizer.Utils.html">Visualizer.Utils</a></li>
            
                <li><a href="../classes/Visualizer.World.html">Visualizer.World</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: build/js/j-visualizer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">

/**
  * Visualizer Object
  * Represents the Object used to manage data (Modules), and the way that the data&#x27;s viewed.
  *
  * The visualization of data is a combined effort of all components contained in this project,
  * accessed through this Object.
  *
  * @class Visualizer
  * @extends Ember.Object
 */

(function() {
  var Visualizer,
    __hasProp = {}.hasOwnProperty;

  this.Visualizer = Visualizer = Ember.Object.extend({

    /**
      * world is a reference to a Visualizer.World Object,
      * representing the main (overview) viewport.
      * Further details/documentation can be found in the vis_world file
      *
      * @property world
      * @type Object
     */
    world: null,

    /**
      * scenes is a reference to a collection of Visualizer.Scene Objects,
      * each representing a Visualization (one or many views, on one or many datasets).
      * Further details/documentation can be found in the vis_scene file
      *
      * @property scenes
      * @type Object
     */
    scenes: Ember.computed(function() {
      return {};
    }),

    /**
      * modules is a reference to a collection of Visualizer.Module Objects,
      * which in turn are responsible for modelling the data collections
      * and their relevant views.
      * Further details/documentation can be found in the _visualizer_module file.
      *
      * @property modules
      * @type Object
     */
    modules: (Ember.computed(function() {
      return Ember.Object.create();
    })).property(),

    /**
      * associations is a reference to a collective Object datastore for cross-Module
      * data.
      *
      * Currently this is implemented as a simple Object, but eventually it
      * may make sense to create standardized Visualizer.Association objects
      * similar to Visualizer.Modules...
      *
      * @property associations
      * @type Object
     */
    associations: (Ember.computed(function() {
      return Ember.Object.create();
    })).property(),

    /**
      * timers is a reference to an Object collection of Timeouts where
      * keys are names given, and values are Timeout ids (as natively generated by setTimeout).
      * This set is used to keep track of actions on a per-Visualizer level when
      * preventing multiple exectution via Visualizer.Utils.waitForRepeatingEvents.
      * Further details/documentation can be found in Visualizer.Utils
      *
      * @property timers
      * @type Object
     */
    timers: Ember.computed(function() {
      return {};
    }),

    /**
      * init is called upon creation of a Visualizer Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * @param world Used for setting up the Visualizer.World Object
      * @constructor
     */
    init: function(world) {
      this.useWorld(world);
      return this.set(&quot;color&quot;, Visualizer.Colorer.create({
        visualizer: this
      }));
    },

    /**
      * useWorld creates a Visualizer.World object, using the a JQuery Object
      * created with the sent parameter. This created object is set as the
      * Visualizer Object&#x27;s world property.
      *
      * @method useWorld
      * @param world Used for setting up the Visualizer.World Object
      * @return {void}
     */
    useWorld: function(world) {
      return this.set(&#x27;world&#x27;, Visualizer.World.create({
        worldObj: $(world),
        visualizer: this
      }));
    },

    /**
      * addModule creates a Visualizer.Module object specified by the moduleClass parameter,
      * using a provided key (to allow differentiation and access). If (optional) content
      * parameter is provided, it will be set as the module&#x27;s content.
      *
      * After the module&#x27;s creation, the Visualizer object is refreshed.
      *
      * @method addModule
      * @param {Module} moduleClass Class of a Visualizer.Module Object to be created
      * @param {String} moduleKey Key used by the Visualizer and module for access and differentiation
      * @param {Array} [content] (Optional) Collection of data to use immediately with the module
      * @return {void}
     */
    addModule: function(moduleClass, moduleKey, content) {
      var module;
      module = moduleClass.create({
        visualizer: this,
        key: moduleKey
      });
      this.set(&quot;modules.&quot; + moduleKey, module);
      if (content != null) {
        this.set(&quot;modules.&quot; + moduleKey + &quot;.content&quot;, content);
      }
      return module.requestRedraw();
    },

    /**
      * refresh sends a request to the current scene to update the visualization
      * based on all current dimensions.
      *
      * The scene will not be drawn unless the Visualizer&#x27;s World is loaded (has a viewport).
      *
      * refresh observes the world&#x27;s state, and the current scene - it should automatically
      * be triggered when any of these things change to ensure an up-to-date Visualization.
      *
      * Note: because Ember Observers currently only watch Array collections (@each), not Object-maps,
      * This will (sadly) not currently watch &#x27;modules.@each.dataset&#x27;...
      *
      * @method refresh
      * @return {void}
     */
    refresh: (function() {
      var _ref;
      if (this.get(&#x27;world.loaded&#x27;)) {
        return (_ref = this.get(&#x27;currentScene&#x27;)) != null ? _ref.reload() : void 0;
      }
    }).observes(&#x27;currentScene&#x27;, &#x27;world.worldObj&#x27;, &#x27;world.loaded&#x27;, &#x27;world.width&#x27;, &#x27;world.height&#x27;),

    /**
      * useScenes updates the Visualizer&#x27;s scenes collection with the inputScenes parameter.
      * For each item in inputScenes , a Visualizer.Scene object is created, with a
      * reference to this instance of Visualizer as its visualizer parameter.
      *
      * @method useScenes
      * @param {Array} inputScenes A set of scenes to create and use for Visualization.
      * @return {void}
     */
    useScenes: function(inputScenes) {
      var scene, _i, _len, _results;
      if (inputScenes == null) {
        inputScenes = [];
      }
      if (!Visualizer.Utils.isArray(inputScenes)) {
        if (typeof console !== &quot;undefined&quot; &amp;&amp; console !== null) {
          if (typeof console.log === &quot;function&quot;) {
            console.log(&quot;Object({})-type input for useScenes is deprecated - please pass an Array instead...&quot;);
          }
        }
        inputScenes = inputScenes.visualizer_scenes;
      }
      _results = [];
      for (_i = 0, _len = inputScenes.length; _i &lt; _len; _i++) {
        scene = inputScenes[_i];
        scene.visualizer = this;
        _results.push(this.set(&quot;scenes.&quot; + scene.identifier, Visualizer.Scene.create(scene)));
      }
      return _results;
    },

    /**
      * setScene updates the Visualizer&#x27;s currentScene property to reference the
      * scene relevant to the method&#x27;s _identifier parameter.
      *
      * @method setScene
      * @param {String} _identifier The key identifier of a scene to use.
      * @return {void}
     */
    setScene: function(_identifier) {
      return this.set(&#x27;currentScene&#x27;, this.get(&quot;scenes.&quot; + _identifier));
    },

    /**
      * destroy cleans up the Visualizer (asking each Module to remove its Views, etc.)
      *
      * @method destroy
      * @return {void}
     */
    destroy: function() {
      var module, moduleName, _ref, _results;
      _ref = this.get(&#x27;modules&#x27;);
      _results = [];
      for (moduleName in _ref) {
        if (!__hasProp.call(_ref, moduleName)) continue;
        module = _ref[moduleName];
        _results.push(typeof module.destroy === &quot;function&quot; ? module.destroy() : void 0);
      }
      return _results;
    }
  });

}).call(this);


/**
  * Visualizer Colorer
  * An Object that manages the many colors of a visualization.
  *
  * @TODO refactor this file, simplify color sets, make generally less confusing.
  *
  * @class Colorer
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  this.Visualizer.Colorer = Ember.Object.extend({

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: null,

    /**
      * init is called upon creation of a Visualizer Colorer Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * @constructor
     */
    init: function() {
      this.get(&quot;_assignedUniq&quot;);
      this.get(&quot;uniquePalette&quot;);
      return this._setUniqueProps();
    },

    /**
      * freshColorPalette creates a new copy of
      * the main color scheme and returns it.
      *
      *
      * @method freshColorPalette
      * @return {Array} A collection of colors
     */
    freshColorPalette: function() {
      return this.get(&quot;_colorScheme&quot;).copy();
    },

    /**
      * fixed accepts a keyword, and attempts to use the keyword
      * to find a relevant color (e.g. &quot;positive&quot; may be &quot;green&quot;).
      *
      * If a valid keyword is passed and a relevant color isn&#x27;t found,
      * a color is assigned from the rotating set.
      *
      * @method fixed
      * @param {String} key The key for which a color is to be found
      * @return {String} A color
     */
    fixed: function(key) {
      if (key == null) {
        key = &quot;&quot;;
      }
      if ((key != null) &amp;&amp; (key = &quot;&quot; + key.toLowerCase()).length) {
        return this.get(&quot;_fixedVals.&quot; + key) || this._rotating_color(key);
      } else {
        return this.get(&#x27;_defaultVal&#x27;);
      }
    },

    /**
      * uniquePalette is a collection of sets of remaining
      * colors. Often it will only have a main set, but some
      * applications may have more complex coloring needs.
      *
      * @property uniquePalette
      * @type Object (of Objects)
      * @required
     */
    uniquePalette: Ember.computed(function() {
      return {};
    }),

    /**
      * _assignedUniq is a collection of sets of used colors
      * (accessed by key).
      * Often it will only have a main set, but some
      * applications may have more complex coloring needs.
      *
      * @property uniquePalette
      * @type Object (of Objects)
      * @required
     */
    _assignedUniq: Ember.computed(function() {
      return {};
    }),

    /**
      * unique is a function used to get a unique color for a
      * given key within a given set (set defaults to &quot;main&quot;).
      *
      * This function has helper properties to handle assigning
      * and unassigning colors, determining what the next color
      * will be, and so on.
      *
      * @TODO consider refactoring / making an Object instead of Function
      * (Sorry for the currently complex code)
      *
      * @method unique
      * @param {String} key The key for which a color is to be found
      * @param {String} [set=&#x27;main&#x27;] The color set used to search get a color
      * @return {String} A color or undefined...
     */
    unique: function(key, set) {
      if (key == null) {
        key = &quot;&quot;;
      }
      if (set == null) {
        set = &quot;main&quot;;
      }
      return this.get(&quot;_assignedUniq.&quot; + set + &quot;.&quot; + key);
    },

    /**
      * _setUniqueProps sets up the helper sub-functions on the &#x60;unique&#x60; function.
      *
      * This is complex, but allows the following syntax style:
      *
      * &#x60;&#x60;&#x60;javascript
      *  colorer.unique(&quot;Dylan&quot;) =&gt; undefined
      *  colorer.unique.next() =&gt; &quot;green&quot;
      *
      *  colorer.unique.assign(&quot;Dylan&quot;) =&gt; undefined
      *  colorer.unique(&quot;Dylan&quot;) =&gt; &quot;green&quot;
      *  colorer.unique.next() =&gt; &quot;purple&quot;
      *
      *  colorer.unique.unassign(&quot;Dylan&quot;) =&gt; undefined
      *  colorer.unique(&quot;Dylan&quot;) =&gt; undefined
      * &#x60;&#x60;&#x60;
      *
      * @method _setUniqueProps
      * @return {void}
      * @private
     */
    _setUniqueProps: function() {

      /**
        * unique.next returns the next available color which can be
        * assigned to a key.
        *
        * @method unique.next
        * @param {String} [set=&#x27;main&#x27;] The color set used to search get a color
        * @return {String} A color
       */
      this.unique.next = (function(_this) {
        return function(set) {
          if (set == null) {
            set = &quot;main&quot;;
          }
          _this.unique._prepareSet(set);
          return _this.get(&quot;uniquePalette.&quot; + set + &quot;.0&quot;);
        };
      })(this);

      /**
        * unique.assign attempts to assign a color to a key within a color set.
        *
        * @method unique.assign
        * @param {String} key The key for which a color is to be assigned
        * @param {String} [set=&#x27;main&#x27;] The color set used to search get a color
        * @return {void}
       */
      this.unique.assign = (function(_this) {
        return function(key, set) {
          var _poppedColor;
          if (set == null) {
            set = &quot;main&quot;;
          }
          _this.unique._prepareSet(set);
          if ((key != null) &amp;&amp; (_this.unique(key, set) == null)) {
            _poppedColor = _this.get(&quot;uniquePalette.&quot; + set).shift() || _this.get(&quot;_defaultAssigned&quot;);
            return _this.set(&quot;_assignedUniq.&quot; + set + &quot;.&quot; + key, _poppedColor);
          }
        };
      })(this);

      /**
        * unique.unassign attempts to unassign a color to a key within a color set.
        * The color is returned to the palette so that it may be reused later.
        *
        * @method unique.unassign
        * @param {String} key The key for which a color is to be unassigned
        * @param {String} [set=&#x27;main&#x27;] The color set used to search get a color
        * @return {void}
       */
      this.unique.unassign = (function(_this) {
        return function(key, set) {
          var _color;
          if (set == null) {
            set = &quot;main&quot;;
          }
          _this.unique._prepareSet(set);
          if (key != null) {
            _color = _this.unique(key, set);
            if ((_color != null) &amp;&amp; (_color !== _this.get(&quot;_defaultUnassigned&quot;))) {
              if (_color !== _this.get(&quot;_defaultAssigned&quot;)) {
                _this.get(&quot;uniquePalette.&quot; + set).push(_color);
              }
              delete _this.get(&quot;_assignedUniq.&quot; + set)[key];
              return _this.get(&quot;uniquePalette.&quot; + set + &quot;.0&quot;);
            }
          }
        };
      })(this);

      /**
        * unique.resetSet removes colors from all keys within the given set,
        * and also replenishes the palette.
        *
        * @method unique.resetSet
        * @param {String} set The color set used to search get a color
        * @return {void}
       */
      this.unique.resetSet = (function(_this) {
        return function(set) {
          _this.get(&quot;_assignedUniq&quot;)[set] = {};
          return _this.get(&quot;uniquePalette&quot;)[set] = _this.freshColorPalette().shuffleVals();
        };
      })(this);

      /**
        * unique._prepareSet creates and prepares a color set if it doesn&#x27;t yet exist.
        *
        * @method unique._prepareSet
        * @param {String} set The color set used to search get a color
        * @return {void}
       */
      return this.unique._prepareSet = (function(_this) {
        return function(set) {
          if (_this.get(&quot;uniquePalette.&quot; + set) == null) {
            return _this.unique.resetSet(set);
          }
        };
      })(this);
    },

    /**
      * _defaultAssigned is the default color to use for highlighting an item
      * (when no other colors in the scheme apply - such as when you
      * wish to have unique colors per-key but have no more colors available)
      *
      * @property _defaultAssigned
      * @type String (a color)
     */
    _defaultAssigned: &quot;#5895B2&quot;,

    /**
      * _defaultUnassigned is the default color to use for
      * non-highlighted, but still colored, items.
      *
      * @property _defaultUnassigned
      * @type String (a color)
     */
    _defaultUnassigned: &quot;#8da3b0&quot;,

    /**
      * _colorScheme is a collection of colors used in the visualization.
      *
      * @property _colorScheme
      * @type Array (of color Strings)
     */
    _colorScheme: [&quot;#3498DB&quot;, &quot;#9B59B6&quot;, &quot;#F2CA27&quot;, &quot;#34495E&quot;, &quot;#1ABC9C&quot;, &quot;#E74C3C&quot;, &quot;#95A5A6&quot;, &quot;#ECF0F1&quot;, &quot;#2ECC71&quot;, &quot;#5895B2&quot;],
    _rotating_color_val: Ember.computed(function() {
      return {};
    }),
    _rotating_keys_used: 0,

    /**
      * _rotating_color returns an assigned color for a given key
      * if available, otherwise assigns a color from the _colorScheme
      * (unlike unique(), if all colors are used up, it
      * starts from the first color again.)
      *
      * @method _rotating_color
      * @param {String} key The key for which a color is to be found
      * @return {String} A color
     */
    _rotating_color: function(key) {
      var color, _scheme;
      if (key != null) {
        if (!(color = this.get(&quot;_rotating_color_val.&quot; + key))) {
          _scheme = this.get(&#x27;_colorScheme&#x27;);
          color = _scheme[(this._rotating_keys_used++) % _scheme.length];
          this.set(&quot;_rotating_color_val.&quot; + key, color);
        }
        return color;
      }
    },
    _defaultVal: Ember.computed(function() {
      var _ref;
      return ((_ref = window.colors) != null ? _ref.defaultSingle : void 0) || this.get(&#x27;_defaultAssigned&#x27;);
    }),

    /**
      * _fixedVals is a collection of key =&gt; color pairs for
      * commonly used keys
      *
      * @property _fixedVals
      * @type Object (key =&gt; String (color) pairs)
      * @required
     */
    _fixedVals: {
      blog: &quot;#28cfc5&quot;,
      board: &quot;#FB913F&quot;,
      twitter: &quot;#2AA9E0&quot;,
      facebook: &quot;#4D69A2&quot;,
      google: &quot;#DD4C39&quot;,
      youtube: &quot;#E14D42&quot;,
      instagram: &quot;#FFCB33&quot;,
      linkedin: &quot;#1E87BD&quot;,
      male: &quot;#29A0CE&quot;,
      unisex: &quot;#d6dadb&quot;,
      female: &quot;#FC4482&quot;,
      positive: &quot;#74B81D&quot;,
      negative: &quot;#E74C3C&quot;,
      neutral: &quot;#A8CEE0&quot;,
      unknown: &quot;#d6dadb&quot;
    }
  });

}).call(this);


/**
  * Visualizer Scene
  * Represents the Object used to manage data (Modules), and the way the data&#x27;s viewed.
  *
  * The visualization of data is a combined effort of all components contained in this project,
  * accessed through this Object.
  *
  * @class Scene
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  var __hasProp = {}.hasOwnProperty;

  this.Visualizer.Scene = Ember.Object.extend({

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: null,

    /**
      * identifier is a string identifier uniquie to this instance of a Scene
      *
      * @property identifier
      * @type String
      * @required
     */
    identifier: null,

    /**
      * title is simply a title for the scene, which some
      * Visualizer applications may find useful for guiding users.
      *
      * @property title
      * @type String
      * @optional
     */
    title: null,

    /**
      * description is simply a description of the scene, which some
      * Visualizer applications may find useful for describing a scene to users.
      *
      * @property description
      * @type String
      * @optional
     */
    description: null,

    /**
      * drawWait is the debounce time waited before running a single widget&#x27;s update.
      * If a widget&#x27;s reload is requested many times in rapid succession it will wait
      * until drawWait milliseconds after the last call before executing the reload.
      *
      * @property drawWait
      * @type Integer (milliseconds)
      * @default 100
      * @required
     */
    drawWait: 100,

    /**
      * fullRefreshWait is an additional debounce time waited before
      * totally updating the scene. This adds some
      *
      * @property fullRefreshWait
      * @type Integer (milliseconds)
      * @default 20
      * @required
     */
    fullRefreshWait: 20,

    /**
      * widgets references a collection of &quot;widget&quot; Objects, each of which
      * should reference a Module, a ModuleView, an operation to call upon the ModuleView,
      * and any additional parameters required (specifications for the ModuleView to follow).
      *
      * @property widgets
      * @type Array
      * @required
     */
    widgets: Ember.computed(function() {
      return [];
    }),

    /**
      * requestedModuleViews is a computed property that returns
      * a dictionary of Modules -&gt; ModuleViews , used to determine which views will be
      * used by the scene. This is particularly useful when changing scenes to determine
      * which Views need to be cleared out, and which will be used in the next scene.
      *
      * Used as a searchable dictionary: &#x60;requestedModuleViews[moduleA][moduleViewA] =&gt; true&#x60;
      *
      * @property requestedModuleViews
      * @type Object
     */
    requestedModuleViews: (function() {
      var moduleKey, moduleList, widget, _i, _len, _name, _ref;
      moduleList = {};
      _ref = this.get(&#x27;widgets&#x27;);
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        widget = _ref[_i];
        moduleKey = (moduleList[_name = widget.module] != null ? moduleList[_name] : moduleList[_name] = {});
        moduleKey[widget.view] = true;
      }
      return moduleList;
    }).property(&#x27;widgets.@each&#x27;),

    /**
      * clearUnusedViews sends a &quot;clear&quot; request to each ModuleView used by the current
      * instance of Visualizer, which isn&#x27;t used in any of this scene&#x27;s widgets.
      * In essence it ensures that any Views that are not currently in use are cleansed.
      *
      * @method clearUnusedViews
      * @chainable
     */
    clearUnusedViews: function() {
      var module, moduleName, view, viewName, _ref, _ref1;
      _ref = this.get(&quot;visualizer.modules&quot;);
      for (moduleName in _ref) {
        if (!__hasProp.call(_ref, moduleName)) continue;
        module = _ref[moduleName];
        _ref1 = module.get(&#x27;moduleViews&#x27;);
        for (viewName in _ref1) {
          if (!__hasProp.call(_ref1, viewName)) continue;
          view = _ref1[viewName];
          if (!this.get(&quot;requestedModuleViews.&quot; + moduleName + &quot;.&quot; + viewName)) {
            if (typeof view.clear === &quot;function&quot;) {
              view.clear();
            }
          }
        }
      }
      return this;
    },

    /**
      * runWidgets iterated this scene&#x27;s widgets, and requests that the ModuleView specified
      * for each widget executes the operation specified for each widget.
      *
      * For example, it may tell one ModuleView, a word cloud, to draw itself, and
      * another ModuleView, a set of icons, to group themselves by common-words.
      *
      * @method runWidgets
      * @chainable
     */
    runWidgets: function(widgets) {
      var widget, _i, _len;
      if (widgets == null) {
        widgets = this.get(&#x27;widgets&#x27;);
      }
      for (_i = 0, _len = widgets.length; _i &lt; _len; _i++) {
        widget = widgets[_i];
        this._runWidget(widget);
      }
      return this;
    },

    /**
      * _runWidget runs the current scene&#x27;s operation for a single widget.
      * Waits for repeating events to prevent multiple refreshes on the
      * same dimensions/parameters.
      *
      * @method _runWidget
      * @return {void}
      * @private
     */
    _runWidget: function(widget) {
      var viewIdentifier;
      if (widget == null) {
        widget = {};
      }
      viewIdentifier = &quot;visualizer.modules.&quot; + widget.module + &quot;.moduleViews.&quot; + widget.view;
      return Visualizer.Utils.waitForRepeatingEvents(((function(_this) {
        return function() {
          var _ref;
          return (_ref = _this.get(viewIdentifier)) != null ? _ref.run(widget.operation, widget.params) : void 0;
        };
      })(this)), this.get(&quot;drawWait&quot;), &quot;Scene Redraw for &quot; + viewIdentifier, this.get(&#x27;visualizer.timers&#x27;));
    },

    /**
      * reload initiates the process of updating the visualization by cleaning out old Views
      * and updating all current widgets.
      *
      * Prevents rapid-exectuion by delaying each request by an amount of time specified
      *  by property drawWait, and afterward only using the most recent request (as a debounce).
      *
      * @method reload
      * @return {void}
     */
    reload: function() {
      return Visualizer.Utils.waitForRepeatingEvents(((function(_this) {
        return function() {
          _this.clearUnusedViews();
          return _this.runWidgets();
        };
      })(this)), this.get(&#x27;fullRefreshWait&#x27;), &quot;Full Scene Reload&quot;, this.get(&#x27;visualizer.timers&#x27;));
    }
  });

}).call(this);


/**
  * Visualizer World
  * Represents an Object used to manage an overview viewport for visualizations.
  *
  * @class World
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  var _handlePhasedButtonClick;

  this.Visualizer.World = Ember.Object.extend({

    /**
      * loaded is a boolean variable indicating whether or the world is
      * prepared to hold a visualization.
      *
      * Currently it simply check&#x27;s whether the world JQuery object exists
      *
      * @property loaded
      * @type Boolean
     */
    loaded: Ember.computed.gt(&#x27;worldObj.length&#x27;, 0),

    /**
      * $ is a method which returns the world&#x27;s JQuery Object, worldObj.
      * If a parameter is passed, $ will attempt to find that parameter
      * withing the structure of the worldObj.
      *
      * @method $
      * @param [selector] A CSS selector to use to find nodes within this World
      * @return {JQuery Object}
     */
    $: function(selector) {
      if (selector != null) {
        return this.get(&#x27;worldObj&#x27;).find(selector);
      } else {
        return this.get(&#x27;worldObj&#x27;);
      }
    },

    /**
      * resize recalculates the width, height, top, and left properties of the
      * worldObj DOM Element
      *
      * This method is automatically called when a World is created.
      *
      * @method resize
      * @return {void}
     */
    resize: (function() {
      var $worldObj, offset, _height;
      $worldObj = this.get(&#x27;worldObj&#x27;);
      if ($worldObj.length) {
        offset = this.get(&#x27;worldObj&#x27;).offset();
        return this.setProperties({
          width: $worldObj.innerWidth(),
          height: (_height = $worldObj.innerHeight()),
          top: offset.top,
          left: offset.left
        });
      }
    }).observes(&#x27;worldObj&#x27;).on(&#x27;init&#x27;),

    /**
      * _bindGlobalEvents binds this World&#x27;s resize event to the window&#x27;s resize,
      * such that every time the window&#x27;s size changes this World attempts to
      * update its properties to reflect the new window.
      *
      * Private, since this method is automatically called when a World is created.
      *
      * @method _bindGlobalEvents
      * @return {void}
      * @private
     */
    _bindGlobalEvents: (function() {
      return $(window).on(&quot;resize&quot;, (function(_this) {
        return function() {
          return _this.resize();
        };
      })(this));
    }).on(&#x27;init&#x27;),

    /**
      * _bindWorldEvents binds and generic event listeners that
      * occur within the World&#x27;s domain
      *
      * Private, since this method is automatically called when a World is created
      * as well as when the worldObj changes to reference a new area.
      *
      * @method _bindWorldEvents
      * @return {void}
      * @private
     */
    _bindWorldEvents: (function() {
      var $world;
      if (($world = this.$()).length) {
        return $world.off(&quot;click&quot;, &quot;.phasedButton&quot;).on(&quot;click&quot;, &quot;.phasedButton&quot;, _handlePhasedButtonClick);
      }
    }).observes(&#x27;worldObj&#x27;).on(&#x27;init&#x27;)
  });


  /**
    * _handlePhasedButtonClick is called when an element with class phasedButton
    * is clicked. Adds a class &#x27;disabledItem&#x27; to the element for 2 seconds;
    * if the element is clicked again before the class &#x27;disabledItem&#x27; class expires,
    * the click will be ignored.
    *
    * @method _handlePhasedButtonClick
    * @return {void}
    * @private
   */

  _handlePhasedButtonClick = function(e) {
    if ($(this).hasClass(&quot;disabledItem&quot;)) {
      e.stopImmediatePropagation();
      return false;
    }
    return Ember.run.next(this, function() {
      return $(this).addExpiringClass(&quot;disabledItem&quot;, 2000);
    });
  };

}).call(this);


/**
  * removeInstancesOf removes traces of a provided value from an Array
  *
  * @method removeInstancesOf
  * @param value The item to find-and-remove
  * @return {Array} The modified Array (with value removed)
  * @for Array
  * @namespace NativeClass
 */

(function() {
  Array.prototype.removeInstancesOf = function(value) {
    var val_location;
    while (true) {
      if ((val_location = this.indexOf(value)) === -1) {
        break;
      } else {
        this.splice(val_location, 1);
      }
    }
    return this;
  };


  /**
    * shuffleVals - Fisher-Yates algorithm for shuffling arrays
    * in-place. (Essentially goes through each slot in array and
    * switches its value with one from a random slot...)
    *
    * @method shuffleVals
    * @return {Array} The shuffled Array
    * @for Array
    * @namespace NativeClass
   */

  Array.prototype.shuffleVals = function() {
    var i, item, randLocation, temp, _i, _len;
    for (i = _i = 0, _len = this.length; _i &lt; _len; i = ++_i) {
      item = this[i];
      randLocation = Math.floor(Math.random() * (i + 1));
      temp = item;
      this[i] = this[randLocation];
      this[randLocation] = temp;
    }
    return this;
  };

}).call(this);

(function() {
  var __hasProp = {}.hasOwnProperty;

  Ember.Object.reopen({

    /**
      * values takes an Object and returns its values
      * (similar to &#x60;.keys()&#x60;)
      *
      * @method values
      * @return {Array} The values
     */
    values: function() {
      var key, value, _results;
      _results = [];
      for (key in this) {
        if (!__hasProp.call(this, key)) continue;
        value = this[key];
        _results.push(value);
      }
      return _results;
    }
  });

}).call(this);


/**
  * addExpiringClass adds a temporary class to a JQuery object.
  * The class has an expiry, after which it is removed.
  *
  * @method addExpiringClass
  * @param {String} [className=&quot;disabled&quot;] Class name
  * @param {Integer} [timeout=1000] Number of milliseconds until class expires
  * @return {void}
  * @for fn
  * @namespace jQuery
 */

(function() {
  jQuery.fn.extend({
    addExpiringClass: function(className, timeout) {
      if (className == null) {
        className = &quot;disabled&quot;;
      }
      if (timeout == null) {
        timeout = 1000;
      }
      this.addClass(className);
      return setTimeout(((function(_this) {
        return function() {
          return _this.removeClass(className);
        };
      })(this)), timeout);
    }
  });

}).call(this);


/**
  * truncateTo ensures a string is no longer than a given size limit.
  * (In the case that it is longer, a suffix can be given for truncation)
  *
  * @method truncateTo
  * @param {Integer} maxLength The maximum length of the String
  * @param {String} [suffix=&quot;…&quot;] A String to use append in case of truncation
  * @return {String} The String cut to maxLength or fewer characters
  * @for String
  * @namespace NativeClass
 */

(function() {
  String.prototype.truncateTo = function(maxLength, suffix) {
    var suffixLength;
    if (suffix == null) {
      suffix = &quot;…&quot;;
    }
    suffixLength = suffix.length;
    if (isNaN(maxLength) || maxLength &lt;= suffixLength) {
      maxLength = suffix.length + 1;
    }
    if (this.length &gt; maxLength) {
      return this.substr(0, maxLength - suffixLength) + suffix;
    }
    return this;
  };


  /**
    * advancedIndexOf searches the object String for a parameter
    * substring, allows additional options (such as case-insensitivity).
    *
    * @method advancedIndexOf
    * @param {String} subString The substring to search for
    * @param {Object} [options] Additional options for searching
    * @return {Integer} Similar to indexOf: -1 if not found,
    *                   otherwise the first start position of the substring.
    * @for String
    * @namespace NativeClass
   */

  String.prototype.advancedIndexOf = function(subString, options) {
    var thisString;
    if (options == null) {
      options = {};
    }
    thisString = this;
    if (options.isCaseInsensitive) {
      thisString = thisString.toLowerCase();
      subString = subString.toLowerCase();
    }
    return thisString.indexOf(subString);
  };


  /**
    * includes searches the object String for a parameter
    * substring, returns boolean, accepts optional parameter
    * to specify whether the search should be case-insensitive.
    *
    * @method includes
    * @param {String} subString The substring to search for
    * @param {Boolean} [isCaseInsensitive=false] Specify whether search is case-sensitive
    * @return {Boolean} True if substring was found, otherwise false
    * @for String
    * @namespace NativeClass
   */

  String.prototype.includes = function(subString, isCaseInsensitive) {
    return this.advancedIndexOf(subString, {
      isCaseInsensitive: isCaseInsensitive
    }) &gt;= 0;
  };


  /**
    * beginsWith searches the start of the object String for a parameter
    * substring, returns boolean, accepts optional parameter
    * to specify whether the search should be case-insensitive.
    *
    * @method beginsWith
    * @param {String} subString The substring to search for
    * @param {Boolean} [isCaseInsensitive=false] Specify whether search is case-sensitive
    * @return {Boolean} True if substring was found at the beginning, otherwise false
    * @for String
    * @namespace NativeClass
   */

  String.prototype.beginsWith = function(subString, isCaseInsensitive) {
    return this.advancedIndexOf(subString, {
      isCaseInsensitive: isCaseInsensitive
    }) === 0;
  };


  /**
    * capitalizeLetter is a String capitalize function adapted from
    * http://stackoverflow.com/a/3291856/624590 .
    * Capitalizes the letter at position n of the object String.
    *
    * @method capitalizeLetter
    * @param {Integer} [n=0] The index of the character to capitalize
    * @return {String} The modified String with capitalized letter
    * @for String
    * @namespace NativeClass
   */

  String.prototype.capitalizeLetter = function(n) {
    var start;
    if (n == null) {
      n = 0;
    }
    start = n === 0 ? &quot;&quot; : this.slice(0, n);
    return start + this.charAt(n).toUpperCase() + this.slice(n + 1);
  };


  /**
    * titleize creates a title-formatted copy of a String
    *
    * @method titleize
    * @return {String} The modified String with updated casing
    * @for String
    * @namespace NativeClass
   */

  String.prototype.titleize = function() {
    return this.toLowerCase().replace(/\b\w/g, function(match) {
      return match.toUpperCase();
    });
  };


  /**
    * removeInitialUnderscore removes the first leading underscore from a String
    *
    * @method removeInitialUnderscore
    * @return {String} The modified String with leading underscore removed
    * @for String
    * @namespace NativeClass
   */

  String.prototype.removeInitialUnderscore = function() {
    return this.replace(/^_/, &quot;&quot;);
  };

}).call(this);


/**
  * Visualizer Utils
  * A collection of common utility functions used in the Visualizer.
  *
  * @class Utils
  * @namespace Visualizer
 */

(function() {
  var getRandomKitten;

  this.Visualizer.Utils = {

    /**
      * existsWithValue checks if a values isn&#x27;t null/undefined
      *
      * @method existsWithValue
      * @param {Object} item An item to check existence of
      * @return {Boolean} false if param is null or undefined, otherwise true
     */
    existsWithValue: function(item) {
      return typeof item !== &quot;undefined&quot; &amp;&amp; item !== null;
    },

    /**
      * waitForRepeatingEvents is a debounce-like function for preventing
      * multiple execution. It should be called with a function and an
      * amount of time to wait. It can also be provided a timer name so as
      * to namespace the blocked items. It can also be called with an Object
      * timer set to allow different objects to not prevent the execution of
      * functions in others.
      *
      * @method waitForRepeatingEvents
      * @param {Function} callback The function to be called at end of waiting time
      * @param {Integer} timeout Number of milliseconds to wait before exectuing function
      * @param [String] timerName A namespace for the debounce @default &quot;default timer&quot;
      * @param [Object] timerSet A collection of timers to use in blocking functions @default {}
      * @return {Integer} The Timeout id assigned by the browser for the created timeout.
     */
    waitForRepeatingEvents: (function() {
      var func, _timers;
      _timers = {};
      return func = function(callback, timeout, timerName, timerSet) {
        var storedTimer;
        if (timerName == null) {
          timerName = &quot;default timer&quot;;
        }
        if (timerSet == null) {
          timerSet = _timers;
        }
        storedTimer = timerSet[timerName];
        if (storedTimer) {
          clearTimeout(storedTimer);
        }
        return timerSet[timerName] = setTimeout(callback, timeout);
      };
    })(),

    /**
      * minVal takes two parameters, returns the smaller
      *
      * @method minVal
      * @param {Untyped} a An item to compare
      * @param {Untyped} b An item to compare
      * @return {Untyped} The smaller item
     */
    minVal: function(a, b) {
      if (a &lt;= b) {
        return a;
      } else {
        return b;
      }
    },

    /**
      * maxVal takes two parameters, returns the larger
      *
      * @method maxVal
      * @param {Untyped} a An item to compare
      * @param {Untyped} b An item to compare
      * @return {Untyped} The larger item
     */
    maxVal: function(a, b) {
      if (a &gt;= b) {
        return a;
      } else {
        return b;
      }
    },

    /**
      * boundedVal takes three parameters: an item, the lower bound,
      * and the upper bound. If the item is between the bounds,
      * the item is returned, otherwise the failed bound is returned.
      *
      * @method boundedVal
      * @param {Untyped} tried_value An item to compare
      * @param {Untyped} minimum_value The lower bound
      * @param {Untyped} maximum_value The upper bound
      * @return {Untyped} An object that&#x27;s within the boundaries.
     */
    boundedVal: function(tried_value, minimum_value, maximum_value) {
      if (minimum_value &gt; tried_value) {
        return minimum_value;
      } else if (maximum_value &lt; tried_value) {
        return maximum_value;
      } else {
        return tried_value;
      }
    },

    /**
      * randBetween provides a random number between two values.
      *
      * @method randBetween
      * @param {Number} [min=0] The lower bound
      * @param {Number} [max=10] The upper bound
      * @return {Number} A random number between min and max
     */
    randBetween: function(min, max) {
      if (min == null) {
        min = 0;
      }
      if (max == null) {
        max = 10;
      }
      return (Math.random() * (max - min)) + min;
    },

    /**
      * randIntBetween provides a random (rounded) Integer between two values.
      *
      * @method randIntBetween
      * @param {Number} min The lower bound
      * @param {Number} max The upper bound
      * @return {Integer} A random Integer between min and max
     */
    randIntBetween: function(min, max) {
      return Math.floor(Visualizer.Utils.randBetween(min, max) || 4);
    },

    /**
      * isArray returns a flag of whether the parameter is of type Array
      *
      * @method isArray
      * @param {Untyped} input The object to check
      * @return {Boolean} Whether the input is an Array or not.
     */
    isArray: function(input) {
      return Object.prototype.toString.call(input) === &quot;[object Array]&quot;;
    },

    /**
      * relativeSizeString parses an input size for either an explicit
      * value, or a value in relationship to some parent value.
      * E.g. &quot;50%&quot; of 900 = 450, &quot;50&quot; = 50, &quot;50px&quot; = 50
      *
      * @method relativeSizeString
      * @param {String} val The input value to parse
      * @param {Number} parentVal A number to use for relative parsing
      * @return {Number} The parsed numeric value
     */
    relativeSizeString: function(val, parentVal) {
      var parsedVal;
      parsedVal = parseInt(val);
      if (typeof val === &quot;string&quot; &amp;&amp; val.indexOf(&quot;%&quot;) &gt;= 0) {
        return (parsedVal / 100) * parentVal;
      } else if (isFinite(parsedVal)) {
        return parsedVal;
      }
    },

    /**
      * intersectionSafe is simple intersection code, iterates along two
      * sorted arrays incrementing the index of the smaller value
      * (if values are equal, it is part of intersection, and so store position and iterate both).
      * Returns array of indices of intersecting values with respect to the first array passed.
      *
      * intersectionSafe is modified from code found on StackOverflow at:
      * http://stackoverflow.com/a/1885660/624590
      *
      * @method intersectionSafe
      * @param {Array} a A sorted Array for comparison
      * @param {Array} b A sorted Array for comparison
      * @return {Array} The intersection of the two Arrays
     */
    intersectionSafe: function(a, b) {
      var a_index, b_index, results;
      a_index = 0;
      b_index = 0;
      results = [];
      while ((a_index &lt; a.length) &amp;&amp; (b_index &lt; b.length)) {
        if (a[a_index] &lt; b[b_index]) {
          a_index++;
        } else if (a[a_index] &gt; b[b_index]) {
          b_index++;
        } else {
          results.push(a_index);
          a_index++;
          b_index++;
        }
      }
      return results;
    },

    /**
      * intersectionCount is a modified form of intersectionSafe that simply
      * increments a counter instead of building an intersection Array.
      * (Faster because increments rather than pushing values to array,
      * also more memory efficient; JSPerf suggests 100% performance increase
      * - beneficial for large datasets...)
      *
      * @method intersectionCount
      * @param {Array} a A sorted Array for comparison
      * @param {Array} b A sorted Array for comparison
      * @return {Integer} The size of the intersection of the two Arrays
     */
    intersectionCount: function(a, b) {
      var a_index, b_index, count;
      a_index = 0;
      b_index = 0;
      count = 0;
      while ((a_index &lt; a.length) &amp;&amp; (b_index &lt; b.length)) {
        if (a[a_index] &lt; b[b_index]) {
          a_index++;
        } else if (a[a_index] &gt; b[b_index]) {
          b_index++;
        } else {
          count++;
          a_index++;
          b_index++;
        }
      }
      return count;
    },

    /**
      * cloneArray creates a copy of an Array.
      *
      * @deprecated use Array.copy instead.
      *
      * @method cloneArray
      * @param {Array} inputArray An Array to copy
      * @return {Array} A copy of the input Array
     */
    cloneArray: function(inputArray) {
      if (typeof console !== &quot;undefined&quot; &amp;&amp; console !== null) {
        if (typeof console.log === &quot;function&quot;) {
          console.log(&quot;cloneArray function is deprecated, please use Array.copy()&quot;);
        }
      }
      return inputArray.slice(0);
    }
  };


  /*
   * FUN!
   */

  Visualizer.Utils.updateKCodePosition = function(key_pressed, position_tracker) {
    if (key_pressed === 38) {
      if (position_tracker &lt; 2) {
        if (position_tracker &lt; 2) {
          position_tracker += 1;
        }
      } else if (position_tracker &gt; 2) {
        position_tracker = 1;
      }
    } else if (key_pressed === 40 &amp;&amp; (position_tracker === 2 || position_tracker === 3)) {
      position_tracker += 1;
    } else if (key_pressed === 37 &amp;&amp; (position_tracker === 4 || position_tracker === 6)) {
      position_tracker += 1;
    } else if (key_pressed === 39 &amp;&amp; (position_tracker === 5 || position_tracker === 7)) {
      position_tracker += 1;
    } else if (key_pressed === 66 &amp;&amp; position_tracker === 8) {
      position_tracker += 1;
    } else if (key_pressed === 65 &amp;&amp; position_tracker === 9) {
      position_tracker = 10;
    } else {
      position_tracker = 0;
    }
    return position_tracker;
  };

  getRandomKitten = function(width, height) {
    if (width &gt; 8) {
      width = Math.floor((Math.random() * 10) + width - 5);
    }
    if (height &gt; 8) {
      height = Math.floor((Math.random() * 10) + height - 5);
    }
    return &quot;http://placekitten.com/&quot; + width + &quot;/&quot; + height;
  };

}).call(this);


/**
  * Visualizer Module
  * A Visualizer Module is a collection of data used for Visualization.
  * It keeps access slightly standardized and offers several helpers to
  * simplify data management.
  *
  * Each Module also has a collection of relevant ModuleViews - Objects that
  * define and take care of how a given Module&#x27;s data can be displayed.
  *
  * @class Module
  * @namespace Visualizer
  * @extends Ember.ArrayController
 */

(function() {
  this.Visualizer.Module = Ember.ArrayController.extend({

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: null,

    /**
      * maxLength is an integer size of how much data should be displayed.
      * Sometimes a project will collect more data than is practical to display
      * to the user (either because it will be confusing, or otherwise too slow);
      * this property represents that limit.
      *
      * @property maxLength
      * @type Integer
      * @required
     */
    maxLength: 100,

    /**
      * content is the full set of data (in Array , Ember.Array) form that is
      * available to this Module.
      *
      * Note: this attribute should only be accessed from the
      * data-management side of your app; it&#x27;s where you dump data, and it&#x27;s
      * what you generally access for front-end filtering. This Module&#x27;s
      * ModuleViews should not access the content, however - they should access
      * the dataset (which is a subset of content).
      *
      * @property content
      * @type Ember.Array
      * @required
     */
    content: (Ember.computed(function() {
      return Ember.A();
    })).property(),

    /**
      * dataset is the subset of content used for current visualization.
      * It can potentially be the exact same data as content, in full,
      * but it can also be a limited/truncated version (often using the
      * maxLength property). It may also filtered down by properties, etc.
      *
      * ModuleViews should only look here for their Module data.
      *
      *
      * @property dataset
      * @type Ember.Array
      * @required
     */
    dataset: Ember.computed.alias(&#x27;arrangedContent&#x27;),

    /**
      * moduleViews an object dictionary/map of Visualizer ModuleView objects,
      * each of which must be relevant to this particular Module&#x27;s data structuring.
      *
      * For example, if this Module is a set of words with frequencies, a WordCloud
      * may be an applicable ModuleView.
      *
      * @property moduleViews
      * @type Ember.Object
      * @required
     */
    moduleViews: (Ember.computed(function() {
      return Ember.Object.create();
    })).property(),

    /**
      * init is called upon creation of a Visualizer Module Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * Any preprocessing that is required to make the Module valid should be
      * done, at latest, on init.
      *
      * If the Module defines a setDefaultViews function (to prepopulate its
      * ModuleViews), that function will be called automatically.
      *
      * @constructor
     */
    init: function() {
      return typeof this.setDefaultViews === &quot;function&quot; ? this.setDefaultViews() : void 0;
    },

    /**
      * requestRedraw sends a request to the current scene
      * to redraw the widgets relevant to this module (and no others).
      *
      * @method requestRedraw
      * @return {void}
     */
    requestRedraw: function() {
      var key, scene, _ref;
      scene = this.get(&#x27;visualizer.currentScene&#x27;);
      key = this.get(&#x27;key&#x27;);
      if ((scene != null) &amp;&amp; (key != null)) {
        return scene.runWidgets((_ref = scene.get(&#x27;widgets&#x27;)) != null ? _ref.filterBy(&#x27;module&#x27;, key) : void 0);
      }
    },

    /**
      * forceLimit sorts the current data by a provided key, and selects only the
      * first maxLength (property) items for this Module&#x27;s dataset, ensuring that
      * the limit to the viewed-data&#x27;s size is enforced.
      *
      * @TODO consider implementing a n-item max-heap data structure instead of sorting
      *
      * @method forceLimit
      * @param {String} [key=&#x27;timestamp&#x27;] Property to use for sorting the data.
      * @return {void}
     */
    forceLimit: function(key) {
      var items;
      if (key == null) {
        key = &#x27;timestamp&#x27;;
      }
      items = this.get(&#x27;dataset&#x27;).sort(function(_a, _b) {
        return _b[key] - _a[key];
      });
      return this.set(&#x27;dataset&#x27;, items.slice(0, this.get(&#x27;maxLength&#x27;)));
    },

    /**
      * groupedBy creates a cached property on the Module to retrieve its data
      * in the form of a two-dimensional Array, where the sub arrays contain
      * this Module&#x27;s dataset split into sets that share a common (passed) property.
      *
      * The outside Array is sorted by length, so the largest groups are at the start.
      *
      * Since the result is cached, it will only be recomputed when the dataset changes,
      * keeping this efficient. The first time you use groupBy for any given property
      * after the data changes (or is created) runs O(nlogn), but each subsequent access
      * is simply O(1) as it simply grabs the previous data. Say what??? :P
      *
      * @method groupedBy
      * @param {String} property Property to use for grouping the data.
      * @return {Array} The Module&#x27;s dataset grouped by the property
     */
    groupedBy: function(property) {
      var cachableProperty, cache, newProp, val;
      cachableProperty = property.replace(&#x27;.&#x27;, &#x27;__&#x27;);
      cache = &quot;__groupedBy_&quot; + cachableProperty;
      if ((val = this.get(cache)) == null) {
        newProp = {};
        newProp[cache] = (function() {
          return this._groupedBy(property).sort(function(_a, _b) {
            return _b.length - _a.length;
          });
        }).property(&quot;dataset.@each.&quot; + property);
        this.reopen(newProp);
      }
      return val || this.get(cache);
    },

    /**
      * _groupedBy groups the Module&#x27;s dataset by a given property, returning
      * an unsorted, two-dimensional array.
      *
      * This method should not be called explicitly, instead developers should
      * go through the &#x60;groupedBy&#x60; method (no leading underscore), which
      * caches the groups (making redraws far more efficient)
      *
      * @method _groupedBy
      * @param {String} property Property to use for grouping the data.
      * @return {Array} The Module&#x27;s dataset grouped by the property
     */
    _groupedBy: function(property) {
      var grouped, item, key, _i, _len, _ref;
      grouped = Ember.Object.create();
      _ref = this.get(&#x27;dataset&#x27;);
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        item = _ref[_i];
        key = Ember.get(item, property);
        (grouped[key] != null ? grouped[key] : grouped[key] = []).push(item);
      }
      return grouped.values();
    }
  });

}).call(this);


/**
  * Visualizer ModuleView
  * Module Views encapsulate the functionality for drawing,
  * coloring, and handling events on visualizations of the data
  * provided by a Module. These are the &quot;visual&quot; side of
  * data visualizations.
  *
  * @class ModuleView
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  this.Visualizer.ModuleView = Ember.Object.extend({

    /**
      * module is a reference to the parent Module for this ModuleView instance.
      *
      * @property module
      * @type Visualizer.Module
      * @required
     */
    module: null,

    /**
      * containerSelector is a string CSS selector used for finding
      * this ModuleView&#x27;s window in a Visualization.
      *
      * Often unique, but occasionally multiple ModuleViews will be
      * written to share a container.
      *
      * Often this property will be specified in a widget&#x27;s parameters,
      * otherwise child classes to ModuleView should specify defaults.
      * If a widget does specify a &#x60;container&#x60; param, it will be set and used
      * running any operation.
      *
      * @property containerSelector
      * @type String
      * @required
     */
    containerSelector: null,

    /**
      * previousSelectors is a list history of selectors that were
      * previously set as this instance of a ModuleView&#x27;s containerSelector.
      *
      * This may be useful for navigation, or for cleaning up after a visualization.
      *
      * @property previousSelectors
      * @type Array
     */
    previousSelectors: Ember.computed(function() {
      return [];
    }),

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: Ember.computed.alias(&#x27;module.visualizer&#x27;),

    /**
      * data is a reference to the visible data for visualization.
      *
      * @property data
      * @type Ember.Array
      * @required
     */
    data: Ember.computed.alias(&#x27;module.dataset&#x27;),

    /**
      * arrangedContent is a reference to all Module data (sorted/arranged).
      * This property should only seldom be accessed because it includes
      * data which is deemed irrelevant by the Module (filtered, etc.)
      *
      * It may, however, be useful if a View decides to animate old data away
      * upon filtering / limiting its viewable data.
      *
      * @property arrangedContent
      * @type Ember.Array
      * @optional
     */
    arrangedContent: Ember.computed.alias(&#x27;module.arrangedContent&#x27;),

    /**
      * dimensionsDidChange is a flag used by ModuleViews to decide how much
      * processing is required when they run an operation.
      *
      * If all dimensions, including visible data, width, and height, are
      * unchanged, often times the old Visualization can simply be shown.
      *
      * Set to true by default, so that ModuleViews can have a proper first-draw.
      *
      * @property dimensionsDidChange
      * @type Boolean
     */
    dimensionsDidChange: true,

    /**
      * init is called upon creation of a Visualizer ModuleView Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * Any preprocessing that is required to make the Module valid should be
      * done, at latest, on init. By default it sets the parent Module reference.
      *
      * @constructor
     */
    init: function(module) {
      return this.set(&#x27;module&#x27;, module);
    },

    /**
      * clear cleanses/hides the current ModuleView from the visualization.
      *
      * This method is often called when a widget representing the ModuleView
      * leaves a visualization (either being removed from a scene,
      * or not being part of a new scene.)
      *
      * Each ModuleView should implement/override this, and should
      * provide (at least) the following functionality:
      *     - hide the container/elements (to prevent overlap/event-disruption),
      *     - unset isDrawn so that next time we know to fully redraw, etc.
      *
      * Optionally, it should also empty the DOM Node/SVG to save memory
      *
      * @method clear
      * @return {void}
     */
    clear: function() {},

    /**
      * destroy totally removes the current ModuleView from the visualization.
      * This should entirely empty and remove any DOM-or-SVG Elements from the
      * document.
      *
      * This method is rarely called unless the Visualizer is being removed entirely.
      *
      * Each ModuleView should implement/override this function.
      *
      * @method destroy
      * @return {void}
     */
    destroy: function() {
      return this.clear();
    },

    /**
      * run is used used to execute a widget&#x27;s operation on a ModuleView.
      * Many times additional parameters are passed, these assist in updating a
      * ModuleView by providing the widget&#x27;s specifications (container, width,
      * any data limitations, etc.)
      *
      * If params includes a &#x60;container&#x60; key, its value will be used to define
      * this particular ModuleView&#x27;s container viewport.
      *
      * @method run
      * @param {String} operation The method on this ModuleView to run.
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
     */
    run: function(operation, params) {
      if (params == null) {
        params = {};
      }
      if (params.container) {
        this.updateSelector(params.container);
      }
      this._presetContainerAttrs(params);
      return typeof this[operation] === &quot;function&quot; ? this[operation](params) : void 0;
    },

    /**
      * updateSelector takes a new containerSelector parameter, and uses it to
      * change this ModuleView&#x27;s viewport. It also updates the &#x60;previousSelectors&#x60;
      * history to contain the selector that was used before this method was called.
      *
      * @method updateSelector
      * @param {String} containerSelector The new selector to use as a viewport
      * @return {void}
     */
    updateSelector: function(containerSelector) {
      var _oldSel;
      if (containerSelector !== (_oldSel = this.get(&#x27;containerSelector&#x27;))) {
        this.clear();
        this.get(&#x27;previousSelectors&#x27;).push(_oldSel);
        return this.set(&#x27;containerSelector&#x27;, containerSelector);
      }
    },

    /**
      * $container is a method which returns the ModuleView&#x27;s container/viewport
      * JQuery Object.
      *
      * If a parameter is passed, $container will attempt to find that parameter
      * withing the structure of its container object.
      *
      * @method $container
      * @param {String} [selector] A CSS selector to use to find nodes within this World
      * @return {JQuery Object}
     */
    $container: function(selector) {
      var spacedSelector;
      spacedSelector = selector ? &quot; &quot; + selector : &quot;&quot;;
      return this.get(&#x27;visualizer.world&#x27;).$(&quot;&quot; + (this.get(&#x27;containerSelector&#x27;)) + spacedSelector);
    },

    /**
      * hardReset clears out the ModuleView and tells it that dimensionsDidChange,
      * so the next redraw/execution is a fresh one (fully recalculated).
      *
      * This is automatically called when the ModuleView&#x27;s data changes.
      *
      * @method hardReset
      * @return {void}
     */
    hardReset: (function() {
      this.set(&#x27;dimensionsDidChange&#x27;, true);
      return this.get(&#x27;module&#x27;).requestRedraw();
    }).observes(&#x27;data&#x27;),

    /**
      * widgetParamedOutlineCSS provides an Object where keys/values map to CSS attributes
      * relevant to the container ONLY for manually specified dimensions/positions.
      *
      * The point of this method is to provide access to data that can be used to set the
      * style of the DOM element containing this ModuleView to the manually-set specifications.
      *
      * If a developer opts to simply use a container&#x27;s size/position, this will return an
      * empty object.
      *
      * @method widgetParamedOutlineCSS
      * @param {Object} [params] Any additional specifications for the operation
      * @return {Object} A collection of manually-specified size/position values
     */
    widgetParamedOutlineCSS: function(params) {
      var cssRules, styleType, _i, _len, _ref;
      if (params == null) {
        params = {};
      }
      cssRules = {};
      _ref = [&#x27;width&#x27;, &#x27;height&#x27;, &#x27;left&#x27;, &#x27;top&#x27;];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        styleType = _ref[_i];
        if (params[styleType] != null) {
          cssRules[styleType] = &quot;&quot; + (this.get(styleType)) + &quot;px&quot;;
        }
      }
      return cssRules;
    },

    /**
      * width getter/setter. Uses _updateDimension to coerce the set value
      * to an expected format (as well as to determine whether a dimension changed).
      *
      * @method width
      * @param {String} key ALWAYS set to &quot;width&quot;
      * @param [value] A value for setting (undefined for getting)
      * @return {Integer} A collection of manually-specified size/position values
      * @private ( ONLY access via &#x60;.get(&#x27;width&#x27;)&#x60; or &#x60;.set(&#x27;width&#x27;, value)&#x60; !!!)
     */
    width: (function(key, value) {
      return this._updateDimension(key, value);
    }).property(),

    /**
      * height getter/setter. Uses _updateDimension to coerce the set value
      * to an expected format (as well as to determine whether a dimension changed).
      *
      * @method height
      * @param {String} key ALWAYS set to &quot;height&quot;
      * @param [value] A value for setting (undefined for getting)
      * @return {Integer} The updated value
      * @private ( ONLY access via &#x60;.get(&#x27;height&#x27;)&#x60; or &#x60;.set(&#x27;height&#x27;, value)&#x60; !!!)
     */
    height: (function(key, value) {
      return this._updateDimension(key, value);
    }).property(),

    /**
      * _updateDimension is used when setting width or height.
      * It accepts a key (which should be set to &quot;width&quot; or &quot;height&quot;),
      * and a value.
      *
      * The value is rounded down to the nearest integer to keep the DOM clean,
      * and to keep determining changes simple.
      *
      * If the value isn&#x27;t the same as this ModuleView&#x27;s previous value for the
      * same key property, dimensionsDidChange flag will be set true so that the
      * ModuleView knows to perform its next operation with full calculations.
      *
      * @method _updateDimension
      * @param {String} key Either &quot;width&quot; or &quot;height&quot;
      * @param [value] A value for setting (undefined if just getting)
      * @return {Integer} The updated value
      * @private ( used by width/height setters )
     */
    _updateDimension: function(key, value) {
      var previousValue;
      if ((value != null)) {
        value = Math.floor(value);
        if (value !== (previousValue = this.get(key))) {
          this.set(&#x27;dimensionsDidChange&#x27;, true);
        }
      }
      return value;
    },

    /**
      * _presetContainerAttrs is used when running an operation to ensure that
      * required attributes based on the viewport (such as available width/height)
      * for visualization are set.
      *
      * If width or height are manually specified, this will not update that attribute -
      * in these cases, the ModuleView should know how to handle explicit dimensions.
      * The &quot;resizable mixin&quot; can help with this (more details in _resizable_mixin file)
      *
      * @method _presetContainerAttrs
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
     */
    _presetContainerAttrs: function(params) {
      var container;
      if (params == null) {
        params = {};
      }
      if (!((params.width != null) &amp;&amp; (params.height != null))) {
        container = this.$container();
        if (params.width == null) {
          this.set(&#x27;width&#x27;, container.width());
        }
        if (params.height == null) {
          return this.set(&#x27;height&#x27;, container.height());
        }
      }
    }
  });

}).call(this);


/**
  * ResizableMixin
  * A helper mixin for ModuleViews which can have their size set manually.
  * This simplifies specifying size, padding, and position of a ModuleView
  * viewport container, and allows values to be set either relatively
  * (as a percentage of the Visualizer&#x27;s World), or explicitly (e.g. &quot;50px&quot; or 50)
  *
  * @class ResizableMixin
  * @extends Ember.Mixin
  * @extensionfor Visualizer.ModuleView
  * @namespace Visualizer.ModuleView
 */

(function() {
  Visualizer.ModuleView.ResizableMixin = Ember.Mixin.create({

    /**
      * run hijacks the ModuleView&#x27;s run method to first attempt to update
      * the viewport&#x27;s size based on the parameter specifications.
      * After attempting to update the size/position of the viewport,
      * the ModuleView&#x27;s run function is allowed to proceed.
      *
      * @method run
      * @param {String} operation The method on this ModuleView to run.
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
     */
    run: function(operation, params) {
      if (params == null) {
        params = {};
      }
      this._updateSize(params);
      return this._super(operation, params);
    },

    /**
      * _updateSize scans the widget-sent params for manually-set
      * size/position values, uses these to set up the ModuleView&#x27;s
      * relevant attributes.
      *
      * @method _updateSize
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
      * @private (called when &#x60;run&#x60; attempts to execute an operation)
     */
    _updateSize: function(params) {
      var dimension, _i, _len, _ref, _results;
      if (params == null) {
        params = {};
      }
      this.get(&quot;visualizer.world&quot;).resize();
      _ref = [
        {
          key: &#x27;width&#x27;
        }, {
          key: &#x27;height&#x27;
        }, {
          key: &quot;left&quot;,
          req: &quot;width&quot;
        }, {
          key: &quot;top&quot;,
          req: &quot;height&quot;
        }
      ];
      _results = [];
      for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
        dimension = _ref[_i];
        _results.push(this._tryUpdateValue(dimension.key, params[dimension.key], params, dimension.req));
      }
      return _results;
    },

    /**
      * _tryUpdateValue given a sizing/position-defining key and value,
      * this method attempts to parse the value and, if it&#x27;s a relative
      * percentage or String, coerce it to an integer.
      *
      * Allows values to be explicit (e.g. 50, or &quot;50px&quot;), or relative
      * to the Visualizer&#x27;s World (e.g. &quot;50%&quot;). Parameter relativeReq is
      * used to specify which of the World&#x27;s parameters should be used to
      * determine a relative size (e.g. &quot;left&quot; uses the World&#x27;s &quot;width&quot;).
      *
      * params may also specify an amount of padding.
      *
      * @method _tryUpdateValue
      * @param {String} key The CSS property being set (width, height, left, top)
      * @param {String} val The value to use for setting the ModuleView property
      * @param {Object} [params] Any additional specifications for the operation.
      * @param {String} [relativeReq=key] The relevant property (to the key) on the World
      * @return {Boolean} True if the dimension changed, false otherwise.
      * @private (called when &#x60;_updateSize&#x60; attempts to execute)
     */
    _tryUpdateValue: function(key, val, params, relativeReq) {
      var newSize, padding;
      if (params == null) {
        params = {};
      }
      if (relativeReq == null) {
        relativeReq = key;
      }
      if (val != null) {
        if (params.padding != null) {
          padding = Visualizer.Utils.relativeSizeString(params.padding, this.get(&quot;visualizer.world.&quot; + relativeReq));
        }
        padding = padding != null ? padding : 15;
        newSize = Math.floor(Visualizer.Utils.relativeSizeString(val, this.get(&quot;visualizer.world.&quot; + relativeReq)) - padding);
        if (isFinite(newSize) &amp;&amp; (this.get(key) !== newSize)) {
          this.set(key, newSize);
          return true;
        }
      }
      return false;
    }
  });

}).call(this);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
