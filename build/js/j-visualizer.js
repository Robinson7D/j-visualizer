
/**
  * Visualizer Object
  * Represents the Object used to manage data (Modules), and the way that the data's viewed.
  *
  * The visualization of data is a combined effort of all components contained in this project,
  * accessed through this Object.
  *
  * @class Visualizer
  * @extends Ember.Object
 */

(function() {
  var Visualizer,
    __hasProp = {}.hasOwnProperty;

  this.Visualizer = Visualizer = Ember.Object.extend({

    /**
      * world is a reference to a Visualizer.World Object,
      * representing the main (overview) viewport.
      * Further details/documentation can be found in the vis_world file
      *
      * @property world
      * @type Object
     */
    world: null,

    /**
      * scenes is a reference to a collection of Visualizer.Scene Objects,
      * each representing a Visualization (one or many views, on one or many datasets).
      * Further details/documentation can be found in the vis_scene file
      *
      * @property scenes
      * @type Object
     */
    scenes: Ember.computed(function() {
      return {};
    }),

    /**
      * modules is a reference to a collection of Visualizer.Module Objects,
      * which in turn are responsible for modelling the data collections
      * and their relevant views.
      * Further details/documentation can be found in the _visualizer_module file.
      *
      * @property modules
      * @type Object
     */
    modules: (Ember.computed(function() {
      return Ember.Object.create();
    })).property(),

    /**
      * associations is a reference to a collective Object datastore for cross-Module
      * data.
      *
      * Currently this is implemented as a simple Object, but eventually it
      * may make sense to create standardized Visualizer.Association objects
      * similar to Visualizer.Modules...
      *
      * @property associations
      * @type Object
     */
    associations: (Ember.computed(function() {
      return Ember.Object.create();
    })).property(),

    /**
      * timers is a reference to an Object collection of Timeouts where
      * keys are names given, and values are Timeout ids (as natively generated by setTimeout).
      * This set is used to keep track of actions on a per-Visualizer level when
      * preventing multiple exectution via Visualizer.Utils.waitForRepeatingEvents.
      * Further details/documentation can be found in Visualizer.Utils
      *
      * @property timers
      * @type Object
     */
    timers: Ember.computed(function() {
      return {};
    }),

    /**
      * init is called upon creation of a Visualizer Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * @param world Used for setting up the Visualizer.World Object
      * @constructor
     */
    init: function(world) {
      this.useWorld(world);
      return this.set("color", Visualizer.Colorer.create({
        visualizer: this
      }));
    },

    /**
      * useWorld creates a Visualizer.World object, using the a JQuery Object
      * created with the sent parameter. This created object is set as the
      * Visualizer Object's world property.
      *
      * @method useWorld
      * @param world Used for setting up the Visualizer.World Object
      * @return {void}
     */
    useWorld: function(world) {
      return this.set('world', Visualizer.World.create({
        worldObj: $(world),
        visualizer: this
      }));
    },

    /**
      * addModule creates a Visualizer.Module object specified by the moduleClass parameter,
      * using a provided key (to allow differentiation and access). If (optional) content
      * parameter is provided, it will be set as the module's content.
      *
      * @method addModule
      * @param {Module} moduleClass Class of a Visualizer.Module Object to be created
      * @param {String} moduleKey Key used by the Visualizer and module for access and differentiation
      * @param {Array} [content] (Optional) Collection of data to use immediately with the module
      * @chainable
     */
    addModule: function(moduleClass, moduleKey, content) {
      var params;
      if (Em.isArray(content)) {
        if (typeof console !== "undefined" && console !== null) {
          if (typeof console.log === "function") {
            console.log("Content Array parameter for addModule is deprecated - please pass an Object of default properties instead. (Use `{content: content}` for old behaviour)");
          }
        }
        content = {
          content: content
        };
      }
      params = $.extend({
        visualizer: this,
        key: moduleKey
      }, content);
      this.set("modules." + moduleKey, moduleClass.create(params));
      return this;
    },

    /**
      * refresh sends a request to the current scene to update the visualization
      * based on all current dimensions.
      *
      * The scene will not be drawn unless the Visualizer's World is loaded (has a viewport).
      *
      * refresh observes the world's state, and the current scene - it should automatically
      * be triggered when any of these things change to ensure an up-to-date Visualization.
      *
      * @method refresh
      * @return {void}
     */
    refresh: (function() {
      var _ref;
      if (this.get('world.loaded')) {
        return (_ref = this.get('currentScene')) != null ? _ref.reload() : void 0;
      }
    }).observes('currentScene', 'world.loaded', 'world.width', 'world.height'),

    /**
      * useScenes updates the Visualizer's scenes collection with the inputScenes parameter.
      * For each item in inputScenes , a Visualizer.Scene object is created, with a
      * reference to this instance of Visualizer as its visualizer parameter.
      *
      * @method useScenes
      * @param {Array} inputScenes A set of scenes to create and use for Visualization.
      * @chainable
     */
    useScenes: function(inputScenes) {
      var scene, _i, _len, _ref;
      if (inputScenes == null) {
        inputScenes = [];
      }
      if (!Visualizer.Utils.isArray(inputScenes)) {
        if (typeof console !== "undefined" && console !== null) {
          if (typeof console.log === "function") {
            console.log("Object({})-type input for useScenes is deprecated - please pass an Array instead.");
          }
        }
        inputScenes = inputScenes.visualizer_scenes;
      }
      for (_i = 0, _len = inputScenes.length; _i < _len; _i++) {
        scene = inputScenes[_i];
        scene.visualizer = this;
        this.set("scenes." + scene.identifier, Visualizer.Scene.create(scene));
      }
      if (!this.get('currentScene')) {
        this.setScene((_ref = inputScenes[0]) != null ? _ref.identifier : void 0);
      }
      return this;
    },

    /**
      * setScene updates the Visualizer's currentScene property to reference the
      * scene relevant to the method's _identifier parameter.
      *
      * @method setScene
      * @param {String} _identifier The key identifier of a scene to use.
      * @return {void}
     */
    setScene: function(_identifier) {
      return this.set('currentScene', this.get("scenes." + _identifier));
    },

    /**
      * destroy cleans up the Visualizer (asking each Module to remove its Views, etc.)
      *
      * @method destroy
      * @return {void}
     */
    destroy: function() {
      var module, moduleName, _ref, _results;
      _ref = this.get('modules');
      _results = [];
      for (moduleName in _ref) {
        if (!__hasProp.call(_ref, moduleName)) continue;
        module = _ref[moduleName];
        _results.push(typeof module.destroy === "function" ? module.destroy() : void 0);
      }
      return _results;
    }
  });

}).call(this);


/**
  * Visualizer Colorer
  * An Object that manages the many colors of a visualization.
  *
  * @TODO refactor this file, simplify color sets, make generally less confusing.
  *
  * @class Colorer
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  this.Visualizer.Colorer = Ember.Object.extend({

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: null,

    /**
      * init is called upon creation of a Visualizer Colorer Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * @constructor
     */
    init: function() {
      this.get("_assignedUniq");
      this.get("uniquePalette");
      return this._setUniqueProps();
    },

    /**
      * freshColorPalette creates a new copy of
      * the main color scheme and returns it.
      *
      *
      * @method freshColorPalette
      * @return {Array} A collection of colors
     */
    freshColorPalette: function() {
      return this.get("_colorScheme").copy();
    },

    /**
      * fixed accepts a keyword, and attempts to use the keyword
      * to find a relevant color (e.g. "positive" may be "green").
      *
      * If a valid keyword is passed and a relevant color isn't found,
      * a color is assigned from the rotating set.
      *
      * @method fixed
      * @param {String} key The key for which a color is to be found
      * @return {String} A color
     */
    fixed: function(key) {
      if (key == null) {
        key = "";
      }
      if ((key != null) && (key = "" + key.toLowerCase()).length) {
        return this.get("_fixedVals." + key) || this._rotating_color(key);
      } else {
        return this.get('_defaultVal');
      }
    },

    /**
      * uniquePalette is a collection of sets of remaining
      * colors. Often it will only have a main set, but some
      * applications may have more complex coloring needs.
      *
      * @property uniquePalette
      * @type Object (of Objects)
      * @required
     */
    uniquePalette: Ember.computed(function() {
      return {};
    }),

    /**
      * _assignedUniq is a collection of sets of used colors
      * (accessed by key).
      * Often it will only have a main set, but some
      * applications may have more complex coloring needs.
      *
      * @property uniquePalette
      * @type Object (of Objects)
      * @required
     */
    _assignedUniq: Ember.computed(function() {
      return {};
    }),

    /**
      * unique is a function used to get a unique color for a
      * given key within a given set (set defaults to "main").
      *
      * This function has helper properties to handle assigning
      * and unassigning colors, determining what the next color
      * will be, and so on.
      *
      * @TODO consider refactoring / making an Object instead of Function
      * (Sorry for the currently complex code)
      *
      * @method unique
      * @param {String} key The key for which a color is to be found
      * @param {String} [set='main'] The color set used to search get a color
      * @return {String} A color or undefined...
     */
    unique: function(key, set) {
      if (key == null) {
        key = "";
      }
      if (set == null) {
        set = "main";
      }
      return this.get("_assignedUniq." + set + "." + key);
    },

    /**
      * _setUniqueProps sets up the helper sub-functions on the `unique` function.
      *
      * This is complex, but allows the following syntax style:
      *
      * ```javascript
      *  colorer.unique("Dylan") => undefined
      *  colorer.unique.next() => "green"
      *
      *  colorer.unique.assign("Dylan") => undefined
      *  colorer.unique("Dylan") => "green"
      *  colorer.unique.next() => "purple"
      *
      *  colorer.unique.unassign("Dylan") => undefined
      *  colorer.unique("Dylan") => undefined
      * ```
      *
      * @method _setUniqueProps
      * @return {void}
      * @private
     */
    _setUniqueProps: function() {

      /**
        * unique.next returns the next available color which can be
        * assigned to a key.
        *
        * @method unique.next
        * @param {String} [set='main'] The color set used to search get a color
        * @return {String} A color
       */
      this.unique.next = (function(_this) {
        return function(set) {
          if (set == null) {
            set = "main";
          }
          _this.unique._prepareSet(set);
          return _this.get("uniquePalette." + set + ".0");
        };
      })(this);

      /**
        * unique.assign attempts to assign a color to a key within a color set.
        *
        * @method unique.assign
        * @param {String} key The key for which a color is to be assigned
        * @param {String} [set='main'] The color set used to search get a color
        * @return {void}
       */
      this.unique.assign = (function(_this) {
        return function(key, set) {
          var _poppedColor;
          if (set == null) {
            set = "main";
          }
          _this.unique._prepareSet(set);
          if ((key != null) && (_this.unique(key, set) == null)) {
            _poppedColor = _this.get("uniquePalette." + set).shift() || _this.get("_defaultAssigned");
            return _this.set("_assignedUniq." + set + "." + key, _poppedColor);
          }
        };
      })(this);

      /**
        * unique.unassign attempts to unassign a color to a key within a color set.
        * The color is returned to the palette so that it may be reused later.
        *
        * @method unique.unassign
        * @param {String} key The key for which a color is to be unassigned
        * @param {String} [set='main'] The color set used to search get a color
        * @return {void}
       */
      this.unique.unassign = (function(_this) {
        return function(key, set) {
          var _color;
          if (set == null) {
            set = "main";
          }
          _this.unique._prepareSet(set);
          if (key != null) {
            _color = _this.unique(key, set);
            if ((_color != null) && (_color !== _this.get("_defaultUnassigned"))) {
              if (_color !== _this.get("_defaultAssigned")) {
                _this.get("uniquePalette." + set).push(_color);
              }
              delete _this.get("_assignedUniq." + set)[key];
              return _this.get("uniquePalette." + set + ".0");
            }
          }
        };
      })(this);

      /**
        * unique.resetSet removes colors from all keys within the given set,
        * and also replenishes the palette.
        *
        * @method unique.resetSet
        * @param {String} set The color set used to search get a color
        * @return {void}
       */
      this.unique.resetSet = (function(_this) {
        return function(set) {
          _this.get("_assignedUniq")[set] = {};
          return _this.get("uniquePalette")[set] = _this.freshColorPalette().shuffleVals();
        };
      })(this);

      /**
        * unique._prepareSet creates and prepares a color set if it doesn't yet exist.
        *
        * @method unique._prepareSet
        * @param {String} set The color set used to search get a color
        * @return {void}
       */
      return this.unique._prepareSet = (function(_this) {
        return function(set) {
          if (_this.get("uniquePalette." + set) == null) {
            return _this.unique.resetSet(set);
          }
        };
      })(this);
    },

    /**
      * _defaultAssigned is the default color to use for highlighting an item
      * (when no other colors in the scheme apply - such as when you
      * wish to have unique colors per-key but have no more colors available)
      *
      * @property _defaultAssigned
      * @type String (a color)
     */
    _defaultAssigned: "#5895B2",

    /**
      * _defaultUnassigned is the default color to use for
      * non-highlighted, but still colored, items.
      *
      * @property _defaultUnassigned
      * @type String (a color)
     */
    _defaultUnassigned: "#8da3b0",

    /**
      * _colorScheme is a collection of colors used in the visualization.
      *
      * @property _colorScheme
      * @type Array (of color Strings)
     */
    _colorScheme: ["#3498DB", "#9B59B6", "#F2CA27", "#34495E", "#1ABC9C", "#E74C3C", "#95A5A6", "#ECF0F1", "#2ECC71", "#5895B2"],
    _rotating_color_val: Ember.computed(function() {
      return {};
    }),
    _rotating_keys_used: 0,

    /**
      * _rotating_color returns an assigned color for a given key
      * if available, otherwise assigns a color from the _colorScheme
      * (unlike unique(), if all colors are used up, it
      * starts from the first color again.)
      *
      * @method _rotating_color
      * @param {String} key The key for which a color is to be found
      * @return {String} A color
     */
    _rotating_color: function(key) {
      var color, _scheme;
      if (key != null) {
        if (!(color = this.get("_rotating_color_val." + key))) {
          _scheme = this.get('_colorScheme');
          color = _scheme[(this._rotating_keys_used++) % _scheme.length];
          this.set("_rotating_color_val." + key, color);
        }
        return color;
      }
    },
    _defaultVal: Ember.computed(function() {
      var _ref;
      return ((_ref = window.colors) != null ? _ref.defaultSingle : void 0) || this.get('_defaultAssigned');
    }),

    /**
      * _fixedVals is a collection of key => color pairs for
      * commonly used keys
      *
      * @property _fixedVals
      * @type Object (key => String (color) pairs)
      * @required
     */
    _fixedVals: {
      blog: "#28cfc5",
      board: "#FB913F",
      twitter: "#2AA9E0",
      facebook: "#4D69A2",
      google: "#DD4C39",
      youtube: "#E14D42",
      instagram: "#FFCB33",
      linkedin: "#1E87BD",
      male: "#29A0CE",
      unisex: "#d6dadb",
      female: "#FC4482",
      positive: "#74B81D",
      negative: "#E74C3C",
      neutral: "#A8CEE0",
      unknown: "#d6dadb"
    }
  });

}).call(this);


/**
  * Visualizer Scene
  * Represents the Object used to manage data (Modules), and the way the data's viewed.
  *
  * The visualization of data is a combined effort of all components contained in this project,
  * accessed through this Object.
  *
  * @class Scene
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  var __hasProp = {}.hasOwnProperty;

  this.Visualizer.Scene = Ember.Object.extend({

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: null,

    /**
      * identifier is a string identifier uniquie to this instance of a Scene
      *
      * @property identifier
      * @type String
      * @required
     */
    identifier: null,

    /**
      * title is simply a title for the scene, which some
      * Visualizer applications may find useful for guiding users.
      *
      * @property title
      * @type String
      * @optional
     */
    title: null,

    /**
      * description is simply a description of the scene, which some
      * Visualizer applications may find useful for describing a scene to users.
      *
      * @property description
      * @type String
      * @optional
     */
    description: null,

    /**
      * drawWait is the debounce time waited before running a single widget's update.
      * If a widget's reload is requested many times in rapid succession it will wait
      * until drawWait milliseconds after the last call before executing the reload.
      *
      * @property drawWait
      * @type Integer (milliseconds)
      * @default 100
      * @required
     */
    drawWait: 100,

    /**
      * fullRefreshWait is an additional debounce time waited before
      * totally updating the scene. This adds some
      *
      * @property fullRefreshWait
      * @type Integer (milliseconds)
      * @default 20
      * @required
     */
    fullRefreshWait: 20,

    /**
      * widgets references a collection of "widget" Objects, each of which
      * should reference a Module, a ModuleView, an operation to call upon the ModuleView,
      * and any additional parameters required (specifications for the ModuleView to follow).
      *
      * @property widgets
      * @type Array
      * @required
     */
    widgets: Ember.computed(function() {
      return [];
    }),

    /**
      * requestedModuleViews is a computed property that returns
      * a dictionary of Modules -> ModuleViews , used to determine which views will be
      * used by the scene. This is particularly useful when changing scenes to determine
      * which Views need to be cleared out, and which will be used in the next scene.
      *
      * Used as a searchable dictionary: `requestedModuleViews[moduleA][moduleViewA] => true`
      *
      * @property requestedModuleViews
      * @type Object
     */
    requestedModuleViews: (function() {
      var moduleKey, moduleList, widget, _i, _len, _name, _ref;
      moduleList = {};
      _ref = this.get('widgets');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        widget = _ref[_i];
        moduleKey = (moduleList[_name = widget.module] != null ? moduleList[_name] : moduleList[_name] = {});
        moduleKey[widget.view] = true;
      }
      return moduleList;
    }).property('widgets.@each'),

    /**
      * clearUnusedViews sends a "clear" request to each ModuleView used by the current
      * instance of Visualizer, which isn't used in any of this scene's widgets.
      * In essence it ensures that any Views that are not currently in use are cleansed.
      *
      * @method clearUnusedViews
      * @chainable
     */
    clearUnusedViews: function() {
      var module, moduleName, view, viewName, _ref, _ref1;
      _ref = this.get("visualizer.modules");
      for (moduleName in _ref) {
        if (!__hasProp.call(_ref, moduleName)) continue;
        module = _ref[moduleName];
        _ref1 = module.get('moduleViews');
        for (viewName in _ref1) {
          if (!__hasProp.call(_ref1, viewName)) continue;
          view = _ref1[viewName];
          if (!this.get("requestedModuleViews." + moduleName + "." + viewName)) {
            if (typeof view.clear === "function") {
              view.clear();
            }
          }
        }
      }
      return this;
    },

    /**
      * runWidgets iterated this scene's widgets, and requests that the ModuleView specified
      * for each widget executes the operation specified for each widget.
      *
      * For example, it may tell one ModuleView, a word cloud, to draw itself, and
      * another ModuleView, a set of icons, to group themselves by common-words.
      *
      * @method runWidgets
      * @chainable
     */
    runWidgets: function(widgets) {
      var widget, _i, _len;
      if (widgets == null) {
        widgets = this.get('widgets');
      }
      for (_i = 0, _len = widgets.length; _i < _len; _i++) {
        widget = widgets[_i];
        this._runWidget(widget);
      }
      return this;
    },

    /**
      * _runWidget runs the current scene's operation for a single widget.
      * Waits for repeating events to prevent multiple refreshes on the
      * same dimensions/parameters.
      *
      * @method _runWidget
      * @return {void}
      * @private
     */
    _runWidget: function(widget) {
      var viewIdentifier;
      if (widget == null) {
        widget = {};
      }
      viewIdentifier = "visualizer.modules." + widget.module + ".moduleViews." + widget.view;
      return Visualizer.Utils.waitForRepeatingEvents(((function(_this) {
        return function() {
          var _ref;
          return (_ref = _this.get(viewIdentifier)) != null ? _ref.run(widget.operation, widget.params) : void 0;
        };
      })(this)), this.get("drawWait"), "Scene Redraw for " + viewIdentifier, this.get('visualizer.timers'));
    },

    /**
      * reload initiates the process of updating the visualization by cleaning out old Views
      * and updating all current widgets.
      *
      * Prevents rapid-exectuion by delaying each request by an amount of time specified
      *  by property drawWait, and afterward only using the most recent request (as a debounce).
      *
      * @method reload
      * @return {void}
     */
    reload: function() {
      return Visualizer.Utils.waitForRepeatingEvents(((function(_this) {
        return function() {
          _this.clearUnusedViews();
          return _this.runWidgets();
        };
      })(this)), this.get('fullRefreshWait'), "Full Scene Reload", this.get('visualizer.timers'));
    }
  });

}).call(this);


/**
  * Visualizer World
  * Represents an Object used to manage an overview viewport for visualizations.
  *
  * @class World
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  var _handlePhasedButtonClick;

  this.Visualizer.World = Ember.Object.extend({

    /**
      * loaded is a boolean variable indicating whether or the world is
      * prepared to hold a visualization.
      *
      * Currently it simply check's whether the world JQuery object exists
      *
      * @property loaded
      * @type Boolean
     */
    loaded: Ember.computed.gt('worldObj.length', 0),

    /**
      * $ is a method which returns the world's JQuery Object, worldObj.
      * If a parameter is passed, $ will attempt to find that parameter
      * withing the structure of the worldObj.
      *
      * @method $
      * @param [selector] A CSS selector to use to find nodes within this World
      * @return {JQuery Object}
     */
    $: function(selector) {
      if (selector != null) {
        return this.get('worldObj').find(selector);
      } else {
        return this.get('worldObj');
      }
    },

    /**
      * resize recalculates the width, height, top, and left properties of the
      * worldObj DOM Element
      *
      * This method is automatically called when a World is created.
      *
      * @method resize
      * @return {void}
     */
    resize: (function() {
      var $worldObj, offset, _height;
      $worldObj = this.get('worldObj');
      if ($worldObj.length) {
        offset = this.get('worldObj').offset();
        return this.setProperties({
          width: $worldObj.innerWidth(),
          height: (_height = $worldObj.innerHeight()),
          top: offset.top,
          left: offset.left
        });
      }
    }).observes('worldObj').on('init'),

    /**
      * _bindGlobalEvents binds this World's resize event to the window's resize,
      * such that every time the window's size changes this World attempts to
      * update its properties to reflect the new window.
      *
      * Private, since this method is automatically called when a World is created.
      *
      * @method _bindGlobalEvents
      * @return {void}
      * @private
     */
    _bindGlobalEvents: (function() {
      return $(window).on("resize", (function(_this) {
        return function() {
          return _this.resize();
        };
      })(this));
    }).on('init'),

    /**
      * _bindWorldEvents binds and generic event listeners that
      * occur within the World's domain
      *
      * Private, since this method is automatically called when a World is created
      * as well as when the worldObj changes to reference a new area.
      *
      * @method _bindWorldEvents
      * @return {void}
      * @private
     */
    _bindWorldEvents: (function() {
      var $world;
      if (($world = this.$()).length) {
        return $world.off("click", ".phasedButton", _handlePhasedButtonClick).on("click", ".phasedButton", _handlePhasedButtonClick);
      }
    }).observes('worldObj').on('init')
  });


  /**
    * _handlePhasedButtonClick is called when an element with class phasedButton
    * is clicked. Adds a class 'disabledItem' to the element for 2 seconds;
    * if the element is clicked again before the class 'disabledItem' class expires,
    * the click will be ignored.
    *
    * @method _handlePhasedButtonClick
    * @return {void}
    * @private
   */

  _handlePhasedButtonClick = function(e) {
    if ($(this).hasClass("disabledItem")) {
      e.stopImmediatePropagation();
      return false;
    }
    return Ember.run.next(this, function() {
      return $(this).addExpiringClass("disabledItem", 2000);
    });
  };

}).call(this);


/**
  * removeInstancesOf removes traces of a provided value from an Array
  *
  * @method removeInstancesOf
  * @param value The item to find-and-remove
  * @return {Array} The modified Array (with value removed)
  * @for Array
  * @namespace NativeClass
 */

(function() {
  Array.prototype.removeInstancesOf = function(value) {
    var val_location;
    while (true) {
      if ((val_location = this.indexOf(value)) === -1) {
        break;
      } else {
        this.splice(val_location, 1);
      }
    }
    return this;
  };


  /**
    * shuffleVals - Fisher-Yates algorithm for shuffling arrays
    * in-place. (Essentially goes through each slot in array and
    * switches its value with one from a random slot...)
    *
    * @method shuffleVals
    * @return {Array} The shuffled Array
    * @for Array
    * @namespace NativeClass
   */

  Array.prototype.shuffleVals = function() {
    var i, item, randLocation, temp, _i, _len;
    for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
      item = this[i];
      randLocation = Math.floor(Math.random() * (i + 1));
      temp = item;
      this[i] = this[randLocation];
      this[randLocation] = temp;
    }
    return this;
  };

}).call(this);

(function() {
  var __hasProp = {}.hasOwnProperty;

  Ember.Object.reopen({

    /**
      * values takes an Object and returns its values
      * (similar to `.keys()`)
      *
      * @method values
      * @return {Array} The values
     */
    values: function() {
      var key, value, _results;
      _results = [];
      for (key in this) {
        if (!__hasProp.call(this, key)) continue;
        value = this[key];
        _results.push(value);
      }
      return _results;
    }
  });

}).call(this);


/**
  * addExpiringClass adds a temporary class to a JQuery object.
  * The class has an expiry, after which it is removed.
  *
  * @method addExpiringClass
  * @param {String} [className="disabled"] Class name
  * @param {Integer} [timeout=1000] Number of milliseconds until class expires
  * @return {void}
  * @for fn
  * @namespace jQuery
 */

(function() {
  jQuery.fn.extend({
    addExpiringClass: function(className, timeout) {
      if (className == null) {
        className = "disabled";
      }
      if (timeout == null) {
        timeout = 1000;
      }
      this.addClass(className);
      return setTimeout(((function(_this) {
        return function() {
          return _this.removeClass(className);
        };
      })(this)), timeout);
    }
  });

}).call(this);


/**
  * truncateTo ensures a string is no longer than a given size limit.
  * (In the case that it is longer, a suffix can be given for truncation)
  *
  * @method truncateTo
  * @param {Integer} maxLength The maximum length of the String
  * @param {String} [suffix="…"] A String to use append in case of truncation
  * @return {String} The String cut to maxLength or fewer characters
  * @for String
  * @namespace NativeClass
 */

(function() {
  String.prototype.truncateTo = function(maxLength, suffix) {
    var suffixLength;
    if (suffix == null) {
      suffix = "…";
    }
    suffixLength = suffix.length;
    if (isNaN(maxLength) || maxLength <= suffixLength) {
      maxLength = suffix.length + 1;
    }
    if (this.length > maxLength) {
      return this.substr(0, maxLength - suffixLength) + suffix;
    }
    return this;
  };


  /**
    * advancedIndexOf searches the object String for a parameter
    * substring, allows additional options (such as case-insensitivity).
    *
    * @method advancedIndexOf
    * @param {String} subString The substring to search for
    * @param {Object} [options] Additional options for searching
    * @return {Integer} Similar to indexOf: -1 if not found,
    *                   otherwise the first start position of the substring.
    * @for String
    * @namespace NativeClass
   */

  String.prototype.advancedIndexOf = function(subString, options) {
    var thisString;
    if (options == null) {
      options = {};
    }
    thisString = this;
    if (options.isCaseInsensitive) {
      thisString = thisString.toLowerCase();
      subString = subString.toLowerCase();
    }
    return thisString.indexOf(subString);
  };


  /**
    * includes searches the object String for a parameter
    * substring, returns boolean, accepts optional parameter
    * to specify whether the search should be case-insensitive.
    *
    * @method includes
    * @param {String} subString The substring to search for
    * @param {Boolean} [isCaseInsensitive=false] Specify whether search is case-sensitive
    * @return {Boolean} True if substring was found, otherwise false
    * @for String
    * @namespace NativeClass
   */

  String.prototype.includes = function(subString, isCaseInsensitive) {
    return this.advancedIndexOf(subString, {
      isCaseInsensitive: isCaseInsensitive
    }) >= 0;
  };


  /**
    * beginsWith searches the start of the object String for a parameter
    * substring, returns boolean, accepts optional parameter
    * to specify whether the search should be case-insensitive.
    *
    * @method beginsWith
    * @param {String} subString The substring to search for
    * @param {Boolean} [isCaseInsensitive=false] Specify whether search is case-sensitive
    * @return {Boolean} True if substring was found at the beginning, otherwise false
    * @for String
    * @namespace NativeClass
   */

  String.prototype.beginsWith = function(subString, isCaseInsensitive) {
    return this.advancedIndexOf(subString, {
      isCaseInsensitive: isCaseInsensitive
    }) === 0;
  };


  /**
    * capitalizeLetter is a String capitalize function adapted from
    * http://stackoverflow.com/a/3291856/624590 .
    * Capitalizes the letter at position n of the object String.
    *
    * @method capitalizeLetter
    * @param {Integer} [n=0] The index of the character to capitalize
    * @return {String} The modified String with capitalized letter
    * @for String
    * @namespace NativeClass
   */

  String.prototype.capitalizeLetter = function(n) {
    var start;
    if (n == null) {
      n = 0;
    }
    start = n === 0 ? "" : this.slice(0, n);
    return start + this.charAt(n).toUpperCase() + this.slice(n + 1);
  };


  /**
    * titleize creates a title-formatted copy of a String
    *
    * @method titleize
    * @return {String} The modified String with updated casing
    * @for String
    * @namespace NativeClass
   */

  String.prototype.titleize = function() {
    return this.toLowerCase().replace(/\b\w/g, function(match) {
      return match.toUpperCase();
    });
  };


  /**
    * removeInitialUnderscore removes the first leading underscore from a String
    *
    * @method removeInitialUnderscore
    * @return {String} The modified String with leading underscore removed
    * @for String
    * @namespace NativeClass
   */

  String.prototype.removeInitialUnderscore = function() {
    return this.replace(/^_/, "");
  };

}).call(this);


/**
  * Visualizer Utils
  * A collection of common utility functions used in the Visualizer.
  *
  * @class Utils
  * @namespace Visualizer
 */

(function() {
  var getRandomKitten;

  this.Visualizer.Utils = {

    /**
      * existsWithValue checks if a values isn't null/undefined
      *
      * @method existsWithValue
      * @param {Object} item An item to check existence of
      * @return {Boolean} false if param is null or undefined, otherwise true
     */
    existsWithValue: function(item) {
      return typeof item !== "undefined" && item !== null;
    },

    /**
      * waitForRepeatingEvents is a debounce-like function for preventing
      * multiple execution. It should be called with a function and an
      * amount of time to wait. It can also be provided a timer name so as
      * to namespace the blocked items. It can also be called with an Object
      * timer set to allow different objects to not prevent the execution of
      * functions in others.
      *
      * @method waitForRepeatingEvents
      * @param {Function} callback The function to be called at end of waiting time
      * @param {Integer} timeout Number of milliseconds to wait before exectuing function
      * @param [String] timerName A namespace for the debounce @default "default timer"
      * @param [Object] timerSet A collection of timers to use in blocking functions @default {}
      * @return {Integer} The Timeout id assigned by the browser for the created timeout.
     */
    waitForRepeatingEvents: (function() {
      var func, _timers;
      _timers = {};
      return func = function(callback, timeout, timerName, timerSet) {
        var storedTimer;
        if (timerName == null) {
          timerName = "default timer";
        }
        if (timerSet == null) {
          timerSet = _timers;
        }
        storedTimer = timerSet[timerName];
        if (storedTimer) {
          clearTimeout(storedTimer);
        }
        return timerSet[timerName] = setTimeout(callback, timeout);
      };
    })(),

    /**
      * minVal takes two parameters, returns the smaller
      *
      * @method minVal
      * @param {Untyped} a An item to compare
      * @param {Untyped} b An item to compare
      * @return {Untyped} The smaller item
     */
    minVal: function(a, b) {
      if (a <= b) {
        return a;
      } else {
        return b;
      }
    },

    /**
      * maxVal takes two parameters, returns the larger
      *
      * @method maxVal
      * @param {Untyped} a An item to compare
      * @param {Untyped} b An item to compare
      * @return {Untyped} The larger item
     */
    maxVal: function(a, b) {
      if (a >= b) {
        return a;
      } else {
        return b;
      }
    },

    /**
      * boundedVal takes three parameters: an item, the lower bound,
      * and the upper bound. If the item is between the bounds,
      * the item is returned, otherwise the failed bound is returned.
      *
      * @method boundedVal
      * @param {Untyped} tried_value An item to compare
      * @param {Untyped} minimum_value The lower bound
      * @param {Untyped} maximum_value The upper bound
      * @return {Untyped} An object that's within the boundaries.
     */
    boundedVal: function(tried_value, minimum_value, maximum_value) {
      if (minimum_value > tried_value) {
        return minimum_value;
      } else if (maximum_value < tried_value) {
        return maximum_value;
      } else {
        return tried_value;
      }
    },

    /**
      * randBetween provides a random number between two values.
      *
      * @method randBetween
      * @param {Number} [min=0] The lower bound
      * @param {Number} [max=10] The upper bound
      * @return {Number} A random number between min and max
     */
    randBetween: function(min, max) {
      if (min == null) {
        min = 0;
      }
      if (max == null) {
        max = 10;
      }
      return (Math.random() * (max - min)) + min;
    },

    /**
      * randIntBetween provides a random (rounded) Integer between two values.
      *
      * @method randIntBetween
      * @param {Number} min The lower bound
      * @param {Number} max The upper bound
      * @return {Integer} A random Integer between min and max
     */
    randIntBetween: function(min, max) {
      return Math.floor(Visualizer.Utils.randBetween(min, max) || 4);
    },

    /**
      * isArray returns a flag of whether the parameter is of type Array
      *
      * @method isArray
      * @param {Untyped} input The object to check
      * @return {Boolean} Whether the input is an Array or not.
     */
    isArray: function(input) {
      return Object.prototype.toString.call(input) === "[object Array]";
    },

    /**
      * relativeSizeString parses an input size for either an explicit
      * value, or a value in relationship to some parent value.
      * E.g. "50%" of 900 = 450, "50" = 50, "50px" = 50
      *
      * @method relativeSizeString
      * @param {String} val The input value to parse
      * @param {Number} parentVal A number to use for relative parsing
      * @return {Number} The parsed numeric value
     */
    relativeSizeString: function(val, parentVal) {
      var parsedVal;
      parsedVal = parseInt(val);
      if (typeof val === "string" && val.indexOf("%") >= 0) {
        return (parsedVal / 100) * parentVal;
      } else if (isFinite(parsedVal)) {
        return parsedVal;
      }
    },

    /**
      * intersectionSafe is simple intersection code, iterates along two
      * sorted arrays incrementing the index of the smaller value
      * (if values are equal, it is part of intersection, and so store position and iterate both).
      * Returns array of indices of intersecting values with respect to the first array passed.
      *
      * intersectionSafe is modified from code found on StackOverflow at:
      * http://stackoverflow.com/a/1885660/624590
      *
      * @method intersectionSafe
      * @param {Array} a A sorted Array for comparison
      * @param {Array} b A sorted Array for comparison
      * @return {Array} The intersection of the two Arrays
     */
    intersectionSafe: function(a, b) {
      var a_index, b_index, results;
      a_index = 0;
      b_index = 0;
      results = [];
      while ((a_index < a.length) && (b_index < b.length)) {
        if (a[a_index] < b[b_index]) {
          a_index++;
        } else if (a[a_index] > b[b_index]) {
          b_index++;
        } else {
          results.push(a_index);
          a_index++;
          b_index++;
        }
      }
      return results;
    },

    /**
      * intersectionCount is a modified form of intersectionSafe that simply
      * increments a counter instead of building an intersection Array.
      * (Faster because increments rather than pushing values to array,
      * also more memory efficient; JSPerf suggests 100% performance increase
      * - beneficial for large datasets...)
      *
      * @method intersectionCount
      * @param {Array} a A sorted Array for comparison
      * @param {Array} b A sorted Array for comparison
      * @return {Integer} The size of the intersection of the two Arrays
     */
    intersectionCount: function(a, b) {
      var a_index, b_index, count;
      a_index = 0;
      b_index = 0;
      count = 0;
      while ((a_index < a.length) && (b_index < b.length)) {
        if (a[a_index] < b[b_index]) {
          a_index++;
        } else if (a[a_index] > b[b_index]) {
          b_index++;
        } else {
          count++;
          a_index++;
          b_index++;
        }
      }
      return count;
    },

    /**
      * cloneArray creates a copy of an Array.
      *
      * @deprecated use Array.copy instead.
      *
      * @method cloneArray
      * @param {Array} inputArray An Array to copy
      * @return {Array} A copy of the input Array
     */
    cloneArray: function(inputArray) {
      if (typeof console !== "undefined" && console !== null) {
        if (typeof console.log === "function") {
          console.log("cloneArray function is deprecated, please use Array.copy()");
        }
      }
      return inputArray.slice(0);
    }
  };


  /*
   * FUN!
   */

  Visualizer.Utils.updateKCodePosition = function(key_pressed, position_tracker) {
    if (key_pressed === 38) {
      if (position_tracker < 2) {
        if (position_tracker < 2) {
          position_tracker += 1;
        }
      } else if (position_tracker > 2) {
        position_tracker = 1;
      }
    } else if (key_pressed === 40 && (position_tracker === 2 || position_tracker === 3)) {
      position_tracker += 1;
    } else if (key_pressed === 37 && (position_tracker === 4 || position_tracker === 6)) {
      position_tracker += 1;
    } else if (key_pressed === 39 && (position_tracker === 5 || position_tracker === 7)) {
      position_tracker += 1;
    } else if (key_pressed === 66 && position_tracker === 8) {
      position_tracker += 1;
    } else if (key_pressed === 65 && position_tracker === 9) {
      position_tracker = 10;
    } else {
      position_tracker = 0;
    }
    return position_tracker;
  };

  getRandomKitten = function(width, height) {
    if (width > 8) {
      width = Math.floor((Math.random() * 10) + width - 5);
    }
    if (height > 8) {
      height = Math.floor((Math.random() * 10) + height - 5);
    }
    return "http://placekitten.com/" + width + "/" + height;
  };

}).call(this);


/**
  * Visualizer Module
  * A Visualizer Module is a collection of data used for Visualization.
  * It keeps access slightly standardized and offers several helpers to
  * simplify data management.
  *
  * Each Module also has a collection of relevant ModuleViews - Objects that
  * define and take care of how a given Module's data can be displayed.
  *
  * @class Module
  * @namespace Visualizer
  * @extends Ember.ArrayController
 */

(function() {
  this.Visualizer.Module = Ember.ArrayController.extend({

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: null,

    /**
      * maxLength is an integer size of how much data should be displayed.
      * Sometimes a project will collect more data than is practical to display
      * to the user (either because it will be confusing, or otherwise too slow);
      * this property represents that limit.
      *
      * @property maxLength
      * @type Integer
      * @required
     */
    maxLength: 100,

    /**
      * content is the full set of data (in Array , Ember.Array) form that is
      * available to this Module.
      *
      * Note: this attribute should only be accessed from the
      * data-management side of your app; it's where you dump data, and it's
      * what you generally access for front-end filtering. This Module's
      * ModuleViews should not access the content, however - they should access
      * the dataset (which is a subset of content).
      *
      * @property content
      * @type Ember.Array
      * @required
     */
    content: (Ember.computed(function() {
      return Ember.A();
    })).property(),

    /**
      * dataset is the subset of content used for current visualization.
      * It can potentially be the exact same data as content, in full,
      * but it can also be a limited/truncated version (often using the
      * maxLength property). It may also filtered down by properties, etc.
      *
      * ModuleViews should only look here for their Module data.
      *
      *
      * @property dataset
      * @type Ember.Array
      * @required
     */
    dataset: Ember.computed.alias('arrangedContent'),

    /**
      * moduleViews an object dictionary/map of Visualizer ModuleView objects,
      * each of which must be relevant to this particular Module's data structuring.
      *
      * For example, if this Module is a set of words with frequencies, a WordCloud
      * may be an applicable ModuleView.
      *
      * @property moduleViews
      * @type Ember.Object
      * @required
     */
    moduleViews: (Ember.computed(function() {
      return Ember.Object.create();
    })).property(),

    /**
      * init is called upon creation of a Visualizer Module Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * Any preprocessing that is required to make the Module valid should be
      * done, at latest, on init.
      *
      * If the Module defines a setDefaultViews function (to prepopulate its
      * ModuleViews), that function will be called automatically.
      *
      * @constructor
     */
    init: function() {
      return typeof this.setDefaultViews === "function" ? this.setDefaultViews() : void 0;
    },

    /**
      * requestRedraw sends a request to the current scene
      * to redraw the widgets relevant to this module (and no others).
      *
      * @method requestRedraw
      * @return {void}
     */
    requestRedraw: function() {
      var key, scene, _ref;
      scene = this.get('visualizer.currentScene');
      key = this.get('key');
      if ((scene != null) && (key != null)) {
        return scene.runWidgets((_ref = scene.get('widgets')) != null ? _ref.filterBy('module', key) : void 0);
      }
    },

    /**
      * forceLimit sorts the current data by a provided key, and selects only the
      * first maxLength (property) items for this Module's dataset, ensuring that
      * the limit to the viewed-data's size is enforced.
      *
      * @TODO consider implementing a n-item max-heap data structure instead of sorting
      *
      * @method forceLimit
      * @param {String} [key='timestamp'] Property to use for sorting the data.
      * @return {void}
     */
    forceLimit: function(key) {
      var items;
      if (key == null) {
        key = 'timestamp';
      }
      items = this.get('dataset').sort(function(_a, _b) {
        return _b[key] - _a[key];
      });
      return this.set('dataset', items.slice(0, this.get('maxLength')));
    },

    /**
      * groupedBy creates a cached property on the Module to retrieve its data
      * in the form of a two-dimensional Array, where the sub arrays contain
      * this Module's dataset split into sets that share a common (passed) property.
      *
      * The outside Array is sorted by length, so the largest groups are at the start.
      *
      * Since the result is cached, it will only be recomputed when the dataset changes,
      * keeping this efficient. The first time you use groupBy for any given property
      * after the data changes (or is created) runs O(nlogn), but each subsequent access
      * is simply O(1) as it simply grabs the previous data. Say what??? :P
      *
      * @method groupedBy
      * @param {String} property Property to use for grouping the data.
      * @return {Array} The Module's dataset grouped by the property
     */
    groupedBy: function(property) {
      var cachableProperty, cache, newProp, val;
      cachableProperty = property.replace('.', '__');
      cache = "__groupedBy_" + cachableProperty;
      if ((val = this.get(cache)) == null) {
        newProp = {};
        newProp[cache] = (function() {
          return this._groupedBy(property).sort(function(_a, _b) {
            return _b.length - _a.length;
          });
        }).property("dataset.@each." + property);
        this.reopen(newProp);
      }
      return val || this.get(cache);
    },

    /**
      * _groupedBy groups the Module's dataset by a given property, returning
      * an unsorted, two-dimensional array.
      *
      * This method should not be called explicitly, instead developers should
      * go through the `groupedBy` method (no leading underscore), which
      * caches the groups (making redraws far more efficient)
      *
      * @method _groupedBy
      * @param {String} property Property to use for grouping the data.
      * @return {Array} The Module's dataset grouped by the property
     */
    _groupedBy: function(property) {
      var grouped, item, key, _i, _len, _ref;
      grouped = Ember.Object.create();
      _ref = this.get('dataset');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        key = Ember.get(item, property);
        (grouped[key] != null ? grouped[key] : grouped[key] = []).push(item);
      }
      return grouped.values();
    }
  });

}).call(this);


/**
  * Visualizer ModuleView
  * Module Views encapsulate the functionality for drawing,
  * coloring, and handling events on visualizations of the data
  * provided by a Module. These are the "visual" side of
  * data visualizations.
  *
  * @class ModuleView
  * @namespace Visualizer
  * @extends Ember.Object
 */

(function() {
  this.Visualizer.ModuleView = Ember.Object.extend({

    /**
      * module is a reference to the parent Module for this ModuleView instance.
      *
      * @property module
      * @type Visualizer.Module
      * @required
     */
    module: null,

    /**
      * containerSelector is a string CSS selector used for finding
      * this ModuleView's window in a Visualization.
      *
      * Often unique, but occasionally multiple ModuleViews will be
      * written to share a container.
      *
      * Often this property will be specified in a widget's parameters,
      * otherwise child classes to ModuleView should specify defaults.
      * If a widget does specify a `container` param, it will be set and used
      * running any operation.
      *
      * @property containerSelector
      * @type String
      * @required
     */
    containerSelector: null,

    /**
      * previousSelectors is a list history of selectors that were
      * previously set as this instance of a ModuleView's containerSelector.
      *
      * This may be useful for navigation, or for cleaning up after a visualization.
      *
      * @property previousSelectors
      * @type Array
     */
    previousSelectors: Ember.computed(function() {
      return [];
    }),

    /**
      * visualizer is a reference to the parent Visualizer instance.
      *
      * @property visualizer
      * @type Visualizer
      * @required
     */
    visualizer: Ember.computed.alias('module.visualizer'),

    /**
      * data is a reference to the visible data for visualization.
      *
      * @property data
      * @type Ember.Array
      * @required
     */
    data: Ember.computed.alias('module.dataset'),

    /**
      * arrangedContent is a reference to all Module data (sorted/arranged).
      * This property should only seldom be accessed because it includes
      * data which is deemed irrelevant by the Module (filtered, etc.)
      *
      * It may, however, be useful if a View decides to animate old data away
      * upon filtering / limiting its viewable data.
      *
      * @property arrangedContent
      * @type Ember.Array
      * @optional
     */
    arrangedContent: Ember.computed.alias('module.arrangedContent'),

    /**
      * dimensionsDidChange is a flag used by ModuleViews to decide how much
      * processing is required when they run an operation.
      *
      * If all dimensions, including visible data, width, and height, are
      * unchanged, often times the old Visualization can simply be shown.
      *
      * Set to true by default, so that ModuleViews can have a proper first-draw.
      *
      * @property dimensionsDidChange
      * @type Boolean
     */
    dimensionsDidChange: true,

    /**
      * init is called upon creation of a Visualizer ModuleView Object.
      * It is responsible for the initial processing and setup of the Object.
      *
      * Any preprocessing that is required to make the Module valid should be
      * done, at latest, on init. By default it sets the parent Module reference.
      *
      * @constructor
     */
    init: function(module) {
      return this.set('module', module);
    },

    /**
      * clear cleanses/hides the current ModuleView from the visualization.
      *
      * This method is often called when a widget representing the ModuleView
      * leaves a visualization (either being removed from a scene,
      * or not being part of a new scene.)
      *
      * Each ModuleView should implement/override this, and should
      * provide (at least) the following functionality:
      *     - hide the container/elements (to prevent overlap/event-disruption),
      *     - unset isDrawn so that next time we know to fully redraw, etc.
      *
      * Optionally, it should also empty the DOM Node/SVG to save memory
      *
      * @method clear
      * @return {void}
     */
    clear: function() {},

    /**
      * destroy totally removes the current ModuleView from the visualization.
      * This should entirely empty and remove any DOM-or-SVG Elements from the
      * document.
      *
      * This method is rarely called unless the Visualizer is being removed entirely.
      *
      * Each ModuleView should implement/override this function.
      *
      * @method destroy
      * @return {void}
     */
    destroy: function() {
      return this.clear();
    },

    /**
      * run is used used to execute a widget's operation on a ModuleView.
      * Many times additional parameters are passed, these assist in updating a
      * ModuleView by providing the widget's specifications (container, width,
      * any data limitations, etc.)
      *
      * If params includes a `container` key, its value will be used to define
      * this particular ModuleView's container viewport.
      *
      * @method run
      * @param {String} operation The method on this ModuleView to run.
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
     */
    run: function(operation, params) {
      if (params == null) {
        params = {};
      }
      if (params.container) {
        this.updateSelector(params.container);
      }
      this._presetContainerAttrs(params);
      return typeof this[operation] === "function" ? this[operation](params) : void 0;
    },

    /**
      * updateSelector takes a new containerSelector parameter, and uses it to
      * change this ModuleView's viewport. It also updates the `previousSelectors`
      * history to contain the selector that was used before this method was called.
      *
      * @method updateSelector
      * @param {String} containerSelector The new selector to use as a viewport
      * @return {void}
     */
    updateSelector: function(containerSelector) {
      var _oldSel;
      if (containerSelector !== (_oldSel = this.get('containerSelector'))) {
        this.clear();
        this.get('previousSelectors').push(_oldSel);
        return this.set('containerSelector', containerSelector);
      }
    },

    /**
      * $container is a method which returns the ModuleView's container/viewport
      * JQuery Object.
      *
      * If a parameter is passed, $container will attempt to find that parameter
      * withing the structure of its container object.
      *
      * @method $container
      * @param {String} [selector] A CSS selector to use to find nodes within this World
      * @return {JQuery Object}
     */
    $container: function(selector) {
      var spacedSelector;
      spacedSelector = selector ? " " + selector : "";
      return this.get('visualizer.world').$("" + (this.get('containerSelector')) + spacedSelector);
    },

    /**
      * hardReset clears out the ModuleView and tells it that dimensionsDidChange,
      * so the next redraw/execution is a fresh one (fully recalculated).
      *
      * This is automatically called when the ModuleView's data changes.
      *
      * @method hardReset
      * @return {void}
     */
    hardReset: (function() {
      this.set('dimensionsDidChange', true);
      return this.get('module').requestRedraw();
    }).observes('data'),

    /**
      * widgetParamedOutlineCSS provides an Object where keys/values map to CSS attributes
      * relevant to the container ONLY for manually specified dimensions/positions.
      *
      * The point of this method is to provide access to data that can be used to set the
      * style of the DOM element containing this ModuleView to the manually-set specifications.
      *
      * If a developer opts to simply use a container's size/position, this will return an
      * empty object.
      *
      * @method widgetParamedOutlineCSS
      * @param {Object} [params] Any additional specifications for the operation
      * @return {Object} A collection of manually-specified size/position values
     */
    widgetParamedOutlineCSS: function(params) {
      var cssRules, styleType, _i, _len, _ref;
      if (params == null) {
        params = {};
      }
      cssRules = {};
      _ref = ['width', 'height', 'left', 'top'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        styleType = _ref[_i];
        if (params[styleType] != null) {
          cssRules[styleType] = "" + (this.get(styleType)) + "px";
        }
      }
      return cssRules;
    },

    /**
      * width getter/setter. Uses _updateDimension to coerce the set value
      * to an expected format (as well as to determine whether a dimension changed).
      *
      * @method width
      * @param {String} key ALWAYS set to "width"
      * @param [value] A value for setting (undefined for getting)
      * @return {Integer} A collection of manually-specified size/position values
      * @private ( ONLY access via `.get('width')` or `.set('width', value)` !!!)
     */
    width: (function(key, value) {
      return this._updateDimension(key, value);
    }).property(),

    /**
      * height getter/setter. Uses _updateDimension to coerce the set value
      * to an expected format (as well as to determine whether a dimension changed).
      *
      * @method height
      * @param {String} key ALWAYS set to "height"
      * @param [value] A value for setting (undefined for getting)
      * @return {Integer} The updated value
      * @private ( ONLY access via `.get('height')` or `.set('height', value)` !!!)
     */
    height: (function(key, value) {
      return this._updateDimension(key, value);
    }).property(),

    /**
      * _updateDimension is used when setting width or height.
      * It accepts a key (which should be set to "width" or "height"),
      * and a value.
      *
      * The value is rounded down to the nearest integer to keep the DOM clean,
      * and to keep determining changes simple.
      *
      * If the value isn't the same as this ModuleView's previous value for the
      * same key property, dimensionsDidChange flag will be set true so that the
      * ModuleView knows to perform its next operation with full calculations.
      *
      * @method _updateDimension
      * @param {String} key Either "width" or "height"
      * @param [value] A value for setting (undefined if just getting)
      * @return {Integer} The updated value
      * @private ( used by width/height setters )
     */
    _updateDimension: function(key, value) {
      var previousValue;
      if ((value != null)) {
        value = Math.floor(value);
        if (value !== (previousValue = this.get(key))) {
          this.set('dimensionsDidChange', true);
        }
      }
      return value;
    },

    /**
      * _presetContainerAttrs is used when running an operation to ensure that
      * required attributes based on the viewport (such as available width/height)
      * for visualization are set.
      *
      * If width or height are manually specified, this will not update that attribute -
      * in these cases, the ModuleView should know how to handle explicit dimensions.
      * The "resizable mixin" can help with this (more details in _resizable_mixin file)
      *
      * @method _presetContainerAttrs
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
     */
    _presetContainerAttrs: function(params) {
      var container;
      if (params == null) {
        params = {};
      }
      if (!((params.width != null) && (params.height != null))) {
        container = this.$container();
        if (params.width == null) {
          this.set('width', container.width());
        }
        if (params.height == null) {
          return this.set('height', container.height());
        }
      }
    }
  });

}).call(this);


/**
  * ResizableMixin
  * A helper mixin for ModuleViews which can have their size set manually.
  * This simplifies specifying size, padding, and position of a ModuleView
  * viewport container, and allows values to be set either relatively
  * (as a percentage of the Visualizer's World), or explicitly (e.g. "50px" or 50)
  *
  * @class ResizableMixin
  * @extends Ember.Mixin
  * @extensionfor Visualizer.ModuleView
  * @namespace Visualizer.ModuleView
 */

(function() {
  Visualizer.ModuleView.ResizableMixin = Ember.Mixin.create({

    /**
      * run hijacks the ModuleView's run method to first attempt to update
      * the viewport's size based on the parameter specifications.
      * After attempting to update the size/position of the viewport,
      * the ModuleView's run function is allowed to proceed.
      *
      * @method run
      * @param {String} operation The method on this ModuleView to run.
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
     */
    run: function(operation, params) {
      if (params == null) {
        params = {};
      }
      this._updateSize(params);
      return this._super(operation, params);
    },

    /**
      * _updateSize scans the widget-sent params for manually-set
      * size/position values, uses these to set up the ModuleView's
      * relevant attributes.
      *
      * @method _updateSize
      * @param {Object} [params] Any additional specifications for the operation.
      * @return {void}
      * @private (called when `run` attempts to execute an operation)
     */
    _updateSize: function(params) {
      var dimension, _i, _len, _ref, _results;
      if (params == null) {
        params = {};
      }
      this.get("visualizer.world").resize();
      _ref = [
        {
          key: 'width'
        }, {
          key: 'height'
        }, {
          key: "left",
          req: "width"
        }, {
          key: "top",
          req: "height"
        }
      ];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dimension = _ref[_i];
        _results.push(this._tryUpdateValue(dimension.key, params[dimension.key], params, dimension.req));
      }
      return _results;
    },

    /**
      * _tryUpdateValue given a sizing/position-defining key and value,
      * this method attempts to parse the value and, if it's a relative
      * percentage or String, coerce it to an integer.
      *
      * Allows values to be explicit (e.g. 50, or "50px"), or relative
      * to the Visualizer's World (e.g. "50%"). Parameter relativeReq is
      * used to specify which of the World's parameters should be used to
      * determine a relative size (e.g. "left" uses the World's "width").
      *
      * params may also specify an amount of padding.
      *
      * @method _tryUpdateValue
      * @param {String} key The CSS property being set (width, height, left, top)
      * @param {String} val The value to use for setting the ModuleView property
      * @param {Object} [params] Any additional specifications for the operation.
      * @param {String} [relativeReq=key] The relevant property (to the key) on the World
      * @return {Boolean} True if the dimension changed, false otherwise.
      * @private (called when `_updateSize` attempts to execute)
     */
    _tryUpdateValue: function(key, val, params, relativeReq) {
      var newSize, padding;
      if (params == null) {
        params = {};
      }
      if (relativeReq == null) {
        relativeReq = key;
      }
      if (val != null) {
        if (params.padding != null) {
          padding = Visualizer.Utils.relativeSizeString(params.padding, this.get("visualizer.world." + relativeReq));
        }
        padding = padding != null ? padding : 15;
        newSize = Math.floor(Visualizer.Utils.relativeSizeString(val, this.get("visualizer.world." + relativeReq)) - padding);
        if (isFinite(newSize) && (this.get(key) !== newSize)) {
          this.set(key, newSize);
          return true;
        }
      }
      return false;
    }
  });

}).call(this);
